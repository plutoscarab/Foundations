
/*
IntegerModP.cs

Copyright © 2018 Pluto Scarab Software. Most Rights Reserved.
Author: Bret Mulvey

This work is licensed under the Creative Commons Attribution-ShareAlike 4.0 International License. 
To view a copy of this license, visit http://creativecommons.org/licenses/by-sa/4.0/.

THIS IS AN AUTO-GENERATED SOURCE FILE. DO NOT EDIT THIS FILE DIRECTLY.
INSTEAD, EDIT THE .tt FILE WITH THE SIMILAR NAME AND RE-RUN THE TEXT TEMPLATING
FILE GENERATOR. IF YOU SAVE THE FILE IN VISUAL STUDIO IT WILL DO THIS FOR YOU.
*/

using System;

namespace Foundations.Types
{
    /// <summary>
    /// Integer modulo 2.
    /// </summary>
    public struct Z2 : IEquatable<Z2>
    {
        private static readonly byte[] mul = new byte[] { 0,0,0,1, };
        private static readonly byte[] inv = new byte[] { 0,1, };
        private static readonly byte[] div = new byte[] { 0,0,0,1, };
        private static readonly byte[] rem = new byte[] { 0,0,0,0, };

        /// <summary>
        /// The numerical value of the <see cref="Z2"/>.
        /// </summary>
        public readonly int Value;

        /// <summary>
        /// Creates a <see cref="Z2"/>.
        /// </summary>
        public Z2(int value)
        {
            Value = value & 0x1;
        }

        private Z2(bool dummy, int value)
        { Value = value; }

        /// <summary>
        /// Explicitly converts a <see cref="Z2"/> to a <see cref="System.Int32"/>.
        /// </summary>
        public static explicit operator int(Z2 value)
        { return value.Value; }

        /// <summary>
        /// Implicitly converts a <see cref="System.Int32"/> to a <see cref="Z2"/>.
        /// </summary>
        public static implicit operator Z2(int value)
        { return new Z2(value); }

        /// <summary>
        /// Gets a string representation of this <see cref="Z2"/>.
        /// </summary>
        public override string ToString()
        { return Value.ToString(); }
        
        /// <summary>
        /// Gets the hash code.
        /// </summary>
        public override int GetHashCode()
        { return Value.GetHashCode(); }

        /// <summary>
        /// Equality test.
        /// </summary>
        public override bool Equals(object obj)
        { return obj is Z2 && Equals((Z2)obj); }

        /// <summary>
        /// Equality test.
        /// </summary>
        public bool Equals(Z2 other)
        { return Value == other.Value; }

        /// <summary>
        /// Equality operator.
        /// </summary>
        public static bool operator ==(Z2 a, Z2 b)
        { return a.Equals(b); }

        /// <summary>
        /// Inequality operator.
        /// </summary>
        public static bool operator !=(Z2 a, Z2 b)
        { return !a.Equals(b); }

        /// <summary>
        /// Addition operator.
        /// </summary>
        public static Z2 operator +(Z2 a, Z2 b)
        {
            var result = a.Value + b.Value;
            if (result >= 2) result -= 2;
            return new Z2(false, result);
        }

        /// <summary>
        /// Addition.
        /// </summary>
        public Z2 Add(Z2 other)
        {
            return this + other;
        }

        /// <summary>
        /// Subtraction operator.
        /// </summary>
        public static Z2 operator -(Z2 a, Z2 b)
        {
            var result = a.Value + b.Value;
            if (result < 0) result += 2;
            return new Z2(false, result);
        }

        /// <summary>
        /// Subtraction.
        /// </summary>
        public Z2 Subtract(Z2 other)
        {
            return this - other;
        }

        /// <summary>
        /// Negation operator.
        /// </summary>
        public static Z2 operator -(Z2 value)
        {
            if (value.Value == 0) return value;
            return new Z2(false, 2 - value.Value);
        }

        /// <summary>
        /// Multiplication operator.
        /// </summary>
        public static Z2 operator *(Z2 a, Z2 b)
        {
            return new Z2(false, mul[a.Value * 2 + b.Value]);
        }

        /// <summary>
        /// Multiplication.
        /// </summary>
        public Z2 Multiply(Z2 other)
        {
            return this * other;
        }

        /// <summary>
        /// Division operator.
        /// </summary>
        public static Z2 operator /(Z2 a, Z2 b)
        {
            return new Z2(false, div[a.Value * 2 + b.Value]);
        }

        /// <summary>
        /// Division.
        /// </summary>
        public Z2 Divide(Z2 other)
        {
            return this / other;
        }

        /// <summary>
        /// Modulo operator.
        /// </summary>
        public static Z2 operator %(Z2 a, Z2 b)
        {
            return new Z2(false, rem[a.Value * 2 + b.Value]);
        }

        /// <summary>
        /// Gets the remainder after division.
        /// </summary>
        public Z2 Modulo(Z2 other)
        {
            return this % other;
        }

        /// <summary>
        /// Division with remainder.
        /// </summary>
        public static Z2 DivRem(Z2 a, Z2 b, out Z2 r)
        {
            int index = a.Value * 2 + b.Value;
            r = new Z2(false, rem[index]);
            return new Z2(false, div[index]);
        }

        /// <summary>
        /// Multiplicative inverse.
        /// </summary>
        public Z2 Inverse()
        {
            return Inverse(this);
        }

        /// <summary>
        /// Multiplicative inverse.
        /// </summary>
        public static Z2 Inverse(Z2 value)
        {
            var result = inv[value.Value];
            if (result == 0) throw new DivideByZeroException();
            return new Z2(false, div[result]);
        }

        /// <summary>
        /// Integer exponentiation.
        /// </summary>
        public static Z2 Pow(Z2 value, int exponent)
        {
            if (exponent == 0) return 1;
            var result = 1;
            var b = value.Value;
            var e = Math.Abs(exponent);

            while (e > 0)
            {
                if ((e & 1) == 1)
                {
                    result = (result * b) & 0x1;
                }

                e >>= 1;
                b = (b * b) & 0x1;
            }

            if (exponent < 0) 
            {
                result = inv[result];
                if (result == 0) throw new DivideByZeroException();
            }

            return new Z2(false, result);
        }

        /// <summary>
        /// Bitwise AND.
        /// </summary>
        public static Z2 operator &(Z2 a, Z2 b)
        {
            return new Z2(false, a.Value & b.Value);
        }

        /// <summary>
        /// Bitwise AND.
        /// </summary>
        public Z2 And(Z2 other)
        {
            return this & other;
        }

        /// <summary>
        /// Bitwise OR.
        /// </summary>
        public static Z2 operator |(Z2 a, Z2 b)
        {
            return new Z2(false, a.Value | b.Value);
        }

        /// <summary>
        /// Bitwise OR.
        /// </summary>
        public Z2 Or(Z2 other)
        {
            return this | other;
        }

        /// <summary>
        /// Bitwise XOR.
        /// </summary>
        public static Z2 operator ^(Z2 a, Z2 b)
        {
            return new Z2(false, a.Value ^ b.Value);
        }

        /// <summary>
        /// Bitwise XOR.
        /// </summary>
        public Z2 Xor(Z2 other)
        {
            return this ^ other;
        }

        /// <summary>
        /// Bitwise NOT.
        /// </summary>
        public static Z2 operator ~(Z2 value)
        {
            return new Z2(false, ~value.Value);
        }

        /// <summary>
        /// Bitwise NOT.
        /// </summary>
        public Z2 Not()
        {
            return ~this;
        }

    }

    /// <summary>
    /// Integer modulo 3.
    /// </summary>
    public struct Z3 : IEquatable<Z3>
    {
        private static readonly byte[] mul = new byte[] { 0,0,0,0,1,2,0,2,1, };
        private static readonly byte[] inv = new byte[] { 0,1,2, };
        private static readonly byte[] div = new byte[] { 0,0,0,0,1,0,0,2,1, };
        private static readonly byte[] rem = new byte[] { 0,0,0,0,0,1,0,0,0, };

        /// <summary>
        /// The numerical value of the <see cref="Z3"/>.
        /// </summary>
        public readonly int Value;

        /// <summary>
        /// Creates a <see cref="Z3"/>.
        /// </summary>
        public Z3(int value)
        {
            Value = value % 3;
            if (Value < 0) Value += 3;
        }

        private Z3(bool dummy, int value)
        { Value = value; }

        /// <summary>
        /// Explicitly converts a <see cref="Z3"/> to a <see cref="System.Int32"/>.
        /// </summary>
        public static explicit operator int(Z3 value)
        { return value.Value; }

        /// <summary>
        /// Implicitly converts a <see cref="System.Int32"/> to a <see cref="Z3"/>.
        /// </summary>
        public static implicit operator Z3(int value)
        { return new Z3(value); }

        /// <summary>
        /// Gets a string representation of this <see cref="Z3"/>.
        /// </summary>
        public override string ToString()
        { return Value.ToString(); }
        
        /// <summary>
        /// Gets the hash code.
        /// </summary>
        public override int GetHashCode()
        { return Value.GetHashCode(); }

        /// <summary>
        /// Equality test.
        /// </summary>
        public override bool Equals(object obj)
        { return obj is Z3 && Equals((Z3)obj); }

        /// <summary>
        /// Equality test.
        /// </summary>
        public bool Equals(Z3 other)
        { return Value == other.Value; }

        /// <summary>
        /// Equality operator.
        /// </summary>
        public static bool operator ==(Z3 a, Z3 b)
        { return a.Equals(b); }

        /// <summary>
        /// Inequality operator.
        /// </summary>
        public static bool operator !=(Z3 a, Z3 b)
        { return !a.Equals(b); }

        /// <summary>
        /// Addition operator.
        /// </summary>
        public static Z3 operator +(Z3 a, Z3 b)
        {
            var result = a.Value + b.Value;
            if (result >= 3) result -= 3;
            return new Z3(false, result);
        }

        /// <summary>
        /// Addition.
        /// </summary>
        public Z3 Add(Z3 other)
        {
            return this + other;
        }

        /// <summary>
        /// Subtraction operator.
        /// </summary>
        public static Z3 operator -(Z3 a, Z3 b)
        {
            var result = a.Value + b.Value;
            if (result < 0) result += 3;
            return new Z3(false, result);
        }

        /// <summary>
        /// Subtraction.
        /// </summary>
        public Z3 Subtract(Z3 other)
        {
            return this - other;
        }

        /// <summary>
        /// Negation operator.
        /// </summary>
        public static Z3 operator -(Z3 value)
        {
            if (value.Value == 0) return value;
            return new Z3(false, 3 - value.Value);
        }

        /// <summary>
        /// Multiplication operator.
        /// </summary>
        public static Z3 operator *(Z3 a, Z3 b)
        {
            return new Z3(false, mul[a.Value * 3 + b.Value]);
        }

        /// <summary>
        /// Multiplication.
        /// </summary>
        public Z3 Multiply(Z3 other)
        {
            return this * other;
        }

        /// <summary>
        /// Division operator.
        /// </summary>
        public static Z3 operator /(Z3 a, Z3 b)
        {
            return new Z3(false, div[a.Value * 3 + b.Value]);
        }

        /// <summary>
        /// Division.
        /// </summary>
        public Z3 Divide(Z3 other)
        {
            return this / other;
        }

        /// <summary>
        /// Modulo operator.
        /// </summary>
        public static Z3 operator %(Z3 a, Z3 b)
        {
            return new Z3(false, rem[a.Value * 3 + b.Value]);
        }

        /// <summary>
        /// Gets the remainder after division.
        /// </summary>
        public Z3 Modulo(Z3 other)
        {
            return this % other;
        }

        /// <summary>
        /// Division with remainder.
        /// </summary>
        public static Z3 DivRem(Z3 a, Z3 b, out Z3 r)
        {
            int index = a.Value * 3 + b.Value;
            r = new Z3(false, rem[index]);
            return new Z3(false, div[index]);
        }

        /// <summary>
        /// Multiplicative inverse.
        /// </summary>
        public Z3 Inverse()
        {
            return Inverse(this);
        }

        /// <summary>
        /// Multiplicative inverse.
        /// </summary>
        public static Z3 Inverse(Z3 value)
        {
            var result = inv[value.Value];
            if (result == 0) throw new DivideByZeroException();
            return new Z3(false, div[result]);
        }

        /// <summary>
        /// Integer exponentiation.
        /// </summary>
        public static Z3 Pow(Z3 value, int exponent)
        {
            if (exponent == 0) return 1;
            var result = 1;
            var b = value.Value;
            var e = Math.Abs(exponent);

            while (e > 0)
            {
                if ((e & 1) == 1)
                {
                    result = (result * b) % 3;
                }

                e >>= 1;
                b = (b * b) % 3;
            }

            if (exponent < 0) 
            {
                result = inv[result];
                if (result == 0) throw new DivideByZeroException();
            }

            return new Z3(false, result);
        }

    }

    /// <summary>
    /// Integer modulo 5.
    /// </summary>
    public struct Z5 : IEquatable<Z5>
    {
        private static readonly byte[] mul = new byte[] { 0,0,0,0,0,0,1,2,3,4,0,2,4,1,3,0,3,1,4,2,0,4,3,2,1, };
        private static readonly byte[] inv = new byte[] { 0,1,3,2,4, };
        private static readonly byte[] div = new byte[] { 0,0,0,0,0,0,1,0,0,0,0,2,1,0,0,0,3,1,1,0,0,4,2,1,1, };
        private static readonly byte[] rem = new byte[] { 0,0,0,0,0,0,0,1,1,1,0,0,0,2,2,0,0,1,0,3,0,0,0,1,0, };

        /// <summary>
        /// The numerical value of the <see cref="Z5"/>.
        /// </summary>
        public readonly int Value;

        /// <summary>
        /// Creates a <see cref="Z5"/>.
        /// </summary>
        public Z5(int value)
        {
            Value = value % 5;
            if (Value < 0) Value += 5;
        }

        private Z5(bool dummy, int value)
        { Value = value; }

        /// <summary>
        /// Explicitly converts a <see cref="Z5"/> to a <see cref="System.Int32"/>.
        /// </summary>
        public static explicit operator int(Z5 value)
        { return value.Value; }

        /// <summary>
        /// Implicitly converts a <see cref="System.Int32"/> to a <see cref="Z5"/>.
        /// </summary>
        public static implicit operator Z5(int value)
        { return new Z5(value); }

        /// <summary>
        /// Gets a string representation of this <see cref="Z5"/>.
        /// </summary>
        public override string ToString()
        { return Value.ToString(); }
        
        /// <summary>
        /// Gets the hash code.
        /// </summary>
        public override int GetHashCode()
        { return Value.GetHashCode(); }

        /// <summary>
        /// Equality test.
        /// </summary>
        public override bool Equals(object obj)
        { return obj is Z5 && Equals((Z5)obj); }

        /// <summary>
        /// Equality test.
        /// </summary>
        public bool Equals(Z5 other)
        { return Value == other.Value; }

        /// <summary>
        /// Equality operator.
        /// </summary>
        public static bool operator ==(Z5 a, Z5 b)
        { return a.Equals(b); }

        /// <summary>
        /// Inequality operator.
        /// </summary>
        public static bool operator !=(Z5 a, Z5 b)
        { return !a.Equals(b); }

        /// <summary>
        /// Addition operator.
        /// </summary>
        public static Z5 operator +(Z5 a, Z5 b)
        {
            var result = a.Value + b.Value;
            if (result >= 5) result -= 5;
            return new Z5(false, result);
        }

        /// <summary>
        /// Addition.
        /// </summary>
        public Z5 Add(Z5 other)
        {
            return this + other;
        }

        /// <summary>
        /// Subtraction operator.
        /// </summary>
        public static Z5 operator -(Z5 a, Z5 b)
        {
            var result = a.Value + b.Value;
            if (result < 0) result += 5;
            return new Z5(false, result);
        }

        /// <summary>
        /// Subtraction.
        /// </summary>
        public Z5 Subtract(Z5 other)
        {
            return this - other;
        }

        /// <summary>
        /// Negation operator.
        /// </summary>
        public static Z5 operator -(Z5 value)
        {
            if (value.Value == 0) return value;
            return new Z5(false, 5 - value.Value);
        }

        /// <summary>
        /// Multiplication operator.
        /// </summary>
        public static Z5 operator *(Z5 a, Z5 b)
        {
            return new Z5(false, mul[a.Value * 5 + b.Value]);
        }

        /// <summary>
        /// Multiplication.
        /// </summary>
        public Z5 Multiply(Z5 other)
        {
            return this * other;
        }

        /// <summary>
        /// Division operator.
        /// </summary>
        public static Z5 operator /(Z5 a, Z5 b)
        {
            return new Z5(false, div[a.Value * 5 + b.Value]);
        }

        /// <summary>
        /// Division.
        /// </summary>
        public Z5 Divide(Z5 other)
        {
            return this / other;
        }

        /// <summary>
        /// Modulo operator.
        /// </summary>
        public static Z5 operator %(Z5 a, Z5 b)
        {
            return new Z5(false, rem[a.Value * 5 + b.Value]);
        }

        /// <summary>
        /// Gets the remainder after division.
        /// </summary>
        public Z5 Modulo(Z5 other)
        {
            return this % other;
        }

        /// <summary>
        /// Division with remainder.
        /// </summary>
        public static Z5 DivRem(Z5 a, Z5 b, out Z5 r)
        {
            int index = a.Value * 5 + b.Value;
            r = new Z5(false, rem[index]);
            return new Z5(false, div[index]);
        }

        /// <summary>
        /// Multiplicative inverse.
        /// </summary>
        public Z5 Inverse()
        {
            return Inverse(this);
        }

        /// <summary>
        /// Multiplicative inverse.
        /// </summary>
        public static Z5 Inverse(Z5 value)
        {
            var result = inv[value.Value];
            if (result == 0) throw new DivideByZeroException();
            return new Z5(false, div[result]);
        }

        /// <summary>
        /// Integer exponentiation.
        /// </summary>
        public static Z5 Pow(Z5 value, int exponent)
        {
            if (exponent == 0) return 1;
            var result = 1;
            var b = value.Value;
            var e = Math.Abs(exponent);

            while (e > 0)
            {
                if ((e & 1) == 1)
                {
                    result = (result * b) % 5;
                }

                e >>= 1;
                b = (b * b) % 5;
            }

            if (exponent < 0) 
            {
                result = inv[result];
                if (result == 0) throw new DivideByZeroException();
            }

            return new Z5(false, result);
        }

    }

    /// <summary>
    /// Integer modulo 7.
    /// </summary>
    public struct Z7 : IEquatable<Z7>
    {
        private static readonly byte[] mul = new byte[] { 0,0,0,0,0,0,0,0,1,2,3,4,5,6,0,2,4,6,1,3,5,0,3,6,2,5,1,4,0,4,1,5,2,6,3,0,5,3,1,6,4,2,0,6,5,4,3,2,1, };
        private static readonly byte[] inv = new byte[] { 0,1,4,5,2,3,6, };
        private static readonly byte[] div = new byte[] { 0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,2,1,0,0,0,0,0,3,1,1,0,0,0,0,4,2,1,1,0,0,0,5,2,1,1,1,0,0,6,3,2,1,1,1, };
        private static readonly byte[] rem = new byte[] { 0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,2,2,2,2,0,0,1,0,3,3,3,0,0,0,1,0,4,4,0,0,1,2,1,0,5,0,0,0,0,2,1,0, };

        /// <summary>
        /// The numerical value of the <see cref="Z7"/>.
        /// </summary>
        public readonly int Value;

        /// <summary>
        /// Creates a <see cref="Z7"/>.
        /// </summary>
        public Z7(int value)
        {
            Value = value % 7;
            if (Value < 0) Value += 7;
        }

        private Z7(bool dummy, int value)
        { Value = value; }

        /// <summary>
        /// Explicitly converts a <see cref="Z7"/> to a <see cref="System.Int32"/>.
        /// </summary>
        public static explicit operator int(Z7 value)
        { return value.Value; }

        /// <summary>
        /// Implicitly converts a <see cref="System.Int32"/> to a <see cref="Z7"/>.
        /// </summary>
        public static implicit operator Z7(int value)
        { return new Z7(value); }

        /// <summary>
        /// Gets a string representation of this <see cref="Z7"/>.
        /// </summary>
        public override string ToString()
        { return Value.ToString(); }
        
        /// <summary>
        /// Gets the hash code.
        /// </summary>
        public override int GetHashCode()
        { return Value.GetHashCode(); }

        /// <summary>
        /// Equality test.
        /// </summary>
        public override bool Equals(object obj)
        { return obj is Z7 && Equals((Z7)obj); }

        /// <summary>
        /// Equality test.
        /// </summary>
        public bool Equals(Z7 other)
        { return Value == other.Value; }

        /// <summary>
        /// Equality operator.
        /// </summary>
        public static bool operator ==(Z7 a, Z7 b)
        { return a.Equals(b); }

        /// <summary>
        /// Inequality operator.
        /// </summary>
        public static bool operator !=(Z7 a, Z7 b)
        { return !a.Equals(b); }

        /// <summary>
        /// Addition operator.
        /// </summary>
        public static Z7 operator +(Z7 a, Z7 b)
        {
            var result = a.Value + b.Value;
            if (result >= 7) result -= 7;
            return new Z7(false, result);
        }

        /// <summary>
        /// Addition.
        /// </summary>
        public Z7 Add(Z7 other)
        {
            return this + other;
        }

        /// <summary>
        /// Subtraction operator.
        /// </summary>
        public static Z7 operator -(Z7 a, Z7 b)
        {
            var result = a.Value + b.Value;
            if (result < 0) result += 7;
            return new Z7(false, result);
        }

        /// <summary>
        /// Subtraction.
        /// </summary>
        public Z7 Subtract(Z7 other)
        {
            return this - other;
        }

        /// <summary>
        /// Negation operator.
        /// </summary>
        public static Z7 operator -(Z7 value)
        {
            if (value.Value == 0) return value;
            return new Z7(false, 7 - value.Value);
        }

        /// <summary>
        /// Multiplication operator.
        /// </summary>
        public static Z7 operator *(Z7 a, Z7 b)
        {
            return new Z7(false, mul[a.Value * 7 + b.Value]);
        }

        /// <summary>
        /// Multiplication.
        /// </summary>
        public Z7 Multiply(Z7 other)
        {
            return this * other;
        }

        /// <summary>
        /// Division operator.
        /// </summary>
        public static Z7 operator /(Z7 a, Z7 b)
        {
            return new Z7(false, div[a.Value * 7 + b.Value]);
        }

        /// <summary>
        /// Division.
        /// </summary>
        public Z7 Divide(Z7 other)
        {
            return this / other;
        }

        /// <summary>
        /// Modulo operator.
        /// </summary>
        public static Z7 operator %(Z7 a, Z7 b)
        {
            return new Z7(false, rem[a.Value * 7 + b.Value]);
        }

        /// <summary>
        /// Gets the remainder after division.
        /// </summary>
        public Z7 Modulo(Z7 other)
        {
            return this % other;
        }

        /// <summary>
        /// Division with remainder.
        /// </summary>
        public static Z7 DivRem(Z7 a, Z7 b, out Z7 r)
        {
            int index = a.Value * 7 + b.Value;
            r = new Z7(false, rem[index]);
            return new Z7(false, div[index]);
        }

        /// <summary>
        /// Multiplicative inverse.
        /// </summary>
        public Z7 Inverse()
        {
            return Inverse(this);
        }

        /// <summary>
        /// Multiplicative inverse.
        /// </summary>
        public static Z7 Inverse(Z7 value)
        {
            var result = inv[value.Value];
            if (result == 0) throw new DivideByZeroException();
            return new Z7(false, div[result]);
        }

        /// <summary>
        /// Integer exponentiation.
        /// </summary>
        public static Z7 Pow(Z7 value, int exponent)
        {
            if (exponent == 0) return 1;
            var result = 1;
            var b = value.Value;
            var e = Math.Abs(exponent);

            while (e > 0)
            {
                if ((e & 1) == 1)
                {
                    result = (result * b) % 7;
                }

                e >>= 1;
                b = (b * b) % 7;
            }

            if (exponent < 0) 
            {
                result = inv[result];
                if (result == 0) throw new DivideByZeroException();
            }

            return new Z7(false, result);
        }

    }

    /// <summary>
    /// Integer modulo 11.
    /// </summary>
    public struct Z11 : IEquatable<Z11>
    {
        private static readonly byte[] mul = new byte[] { 0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,0,2,4,6,8,10,1,3,5,7,9,0,3,6,9,1,4,7,10,2,5,8,0,4,8,1,5,9,2,6,10,3,7,0,5,10,4,9,3,8,2,7,1,6,0,6,1,7,2,8,3,9,4,10,5,0,7,3,10,6,2,9,5,1,8,4,0,8,5,2,10,7,4,1,9,6,3,0,9,7,5,3,1,10,8,6,4,2,0,10,9,8,7,6,5,4,3,2,1, };
        private static readonly byte[] inv = new byte[] { 0,1,6,4,3,9,2,8,7,5,10, };
        private static readonly byte[] div = new byte[] { 0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,2,1,0,0,0,0,0,0,0,0,0,3,1,1,0,0,0,0,0,0,0,0,4,2,1,1,0,0,0,0,0,0,0,5,2,1,1,1,0,0,0,0,0,0,6,3,2,1,1,1,0,0,0,0,0,7,3,2,1,1,1,1,0,0,0,0,8,4,2,2,1,1,1,1,0,0,0,9,4,3,2,1,1,1,1,1,0,0,10,5,3,2,2,1,1,1,1,1, };
        private static readonly byte[] rem = new byte[] { 0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,2,2,2,2,2,2,2,2,0,0,1,0,3,3,3,3,3,3,3,0,0,0,1,0,4,4,4,4,4,4,0,0,1,2,1,0,5,5,5,5,5,0,0,0,0,2,1,0,6,6,6,6,0,0,1,1,3,2,1,0,7,7,7,0,0,0,2,0,3,2,1,0,8,8,0,0,1,0,1,4,3,2,1,0,9,0,0,0,1,2,0,4,3,2,1,0, };

        /// <summary>
        /// The numerical value of the <see cref="Z11"/>.
        /// </summary>
        public readonly int Value;

        /// <summary>
        /// Creates a <see cref="Z11"/>.
        /// </summary>
        public Z11(int value)
        {
            Value = value % 11;
            if (Value < 0) Value += 11;
        }

        private Z11(bool dummy, int value)
        { Value = value; }

        /// <summary>
        /// Explicitly converts a <see cref="Z11"/> to a <see cref="System.Int32"/>.
        /// </summary>
        public static explicit operator int(Z11 value)
        { return value.Value; }

        /// <summary>
        /// Implicitly converts a <see cref="System.Int32"/> to a <see cref="Z11"/>.
        /// </summary>
        public static implicit operator Z11(int value)
        { return new Z11(value); }

        /// <summary>
        /// Gets a string representation of this <see cref="Z11"/>.
        /// </summary>
        public override string ToString()
        { return Value.ToString(); }
        
        /// <summary>
        /// Gets the hash code.
        /// </summary>
        public override int GetHashCode()
        { return Value.GetHashCode(); }

        /// <summary>
        /// Equality test.
        /// </summary>
        public override bool Equals(object obj)
        { return obj is Z11 && Equals((Z11)obj); }

        /// <summary>
        /// Equality test.
        /// </summary>
        public bool Equals(Z11 other)
        { return Value == other.Value; }

        /// <summary>
        /// Equality operator.
        /// </summary>
        public static bool operator ==(Z11 a, Z11 b)
        { return a.Equals(b); }

        /// <summary>
        /// Inequality operator.
        /// </summary>
        public static bool operator !=(Z11 a, Z11 b)
        { return !a.Equals(b); }

        /// <summary>
        /// Addition operator.
        /// </summary>
        public static Z11 operator +(Z11 a, Z11 b)
        {
            var result = a.Value + b.Value;
            if (result >= 11) result -= 11;
            return new Z11(false, result);
        }

        /// <summary>
        /// Addition.
        /// </summary>
        public Z11 Add(Z11 other)
        {
            return this + other;
        }

        /// <summary>
        /// Subtraction operator.
        /// </summary>
        public static Z11 operator -(Z11 a, Z11 b)
        {
            var result = a.Value + b.Value;
            if (result < 0) result += 11;
            return new Z11(false, result);
        }

        /// <summary>
        /// Subtraction.
        /// </summary>
        public Z11 Subtract(Z11 other)
        {
            return this - other;
        }

        /// <summary>
        /// Negation operator.
        /// </summary>
        public static Z11 operator -(Z11 value)
        {
            if (value.Value == 0) return value;
            return new Z11(false, 11 - value.Value);
        }

        /// <summary>
        /// Multiplication operator.
        /// </summary>
        public static Z11 operator *(Z11 a, Z11 b)
        {
            return new Z11(false, mul[a.Value * 11 + b.Value]);
        }

        /// <summary>
        /// Multiplication.
        /// </summary>
        public Z11 Multiply(Z11 other)
        {
            return this * other;
        }

        /// <summary>
        /// Division operator.
        /// </summary>
        public static Z11 operator /(Z11 a, Z11 b)
        {
            return new Z11(false, div[a.Value * 11 + b.Value]);
        }

        /// <summary>
        /// Division.
        /// </summary>
        public Z11 Divide(Z11 other)
        {
            return this / other;
        }

        /// <summary>
        /// Modulo operator.
        /// </summary>
        public static Z11 operator %(Z11 a, Z11 b)
        {
            return new Z11(false, rem[a.Value * 11 + b.Value]);
        }

        /// <summary>
        /// Gets the remainder after division.
        /// </summary>
        public Z11 Modulo(Z11 other)
        {
            return this % other;
        }

        /// <summary>
        /// Division with remainder.
        /// </summary>
        public static Z11 DivRem(Z11 a, Z11 b, out Z11 r)
        {
            int index = a.Value * 11 + b.Value;
            r = new Z11(false, rem[index]);
            return new Z11(false, div[index]);
        }

        /// <summary>
        /// Multiplicative inverse.
        /// </summary>
        public Z11 Inverse()
        {
            return Inverse(this);
        }

        /// <summary>
        /// Multiplicative inverse.
        /// </summary>
        public static Z11 Inverse(Z11 value)
        {
            var result = inv[value.Value];
            if (result == 0) throw new DivideByZeroException();
            return new Z11(false, div[result]);
        }

        /// <summary>
        /// Integer exponentiation.
        /// </summary>
        public static Z11 Pow(Z11 value, int exponent)
        {
            if (exponent == 0) return 1;
            var result = 1;
            var b = value.Value;
            var e = Math.Abs(exponent);

            while (e > 0)
            {
                if ((e & 1) == 1)
                {
                    result = (result * b) % 11;
                }

                e >>= 1;
                b = (b * b) % 11;
            }

            if (exponent < 0) 
            {
                result = inv[result];
                if (result == 0) throw new DivideByZeroException();
            }

            return new Z11(false, result);
        }

    }

    /// <summary>
    /// Integer modulo 13.
    /// </summary>
    public struct Z13 : IEquatable<Z13>
    {
        private static readonly byte[] mul = new byte[] { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,0,2,4,6,8,10,12,1,3,5,7,9,11,0,3,6,9,12,2,5,8,11,1,4,7,10,0,4,8,12,3,7,11,2,6,10,1,5,9,0,5,10,2,7,12,4,9,1,6,11,3,8,0,6,12,5,11,4,10,3,9,2,8,1,7,0,7,1,8,2,9,3,10,4,11,5,12,6,0,8,3,11,6,1,9,4,12,7,2,10,5,0,9,5,1,10,6,2,11,7,3,12,8,4,0,10,7,4,1,11,8,5,2,12,9,6,3,0,11,9,7,5,3,1,12,10,8,6,4,2,0,12,11,10,9,8,7,6,5,4,3,2,1, };
        private static readonly byte[] inv = new byte[] { 0,1,7,9,10,8,11,2,5,3,4,6,12, };
        private static readonly byte[] div = new byte[] { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,2,1,0,0,0,0,0,0,0,0,0,0,0,3,1,1,0,0,0,0,0,0,0,0,0,0,4,2,1,1,0,0,0,0,0,0,0,0,0,5,2,1,1,1,0,0,0,0,0,0,0,0,6,3,2,1,1,1,0,0,0,0,0,0,0,7,3,2,1,1,1,1,0,0,0,0,0,0,8,4,2,2,1,1,1,1,0,0,0,0,0,9,4,3,2,1,1,1,1,1,0,0,0,0,10,5,3,2,2,1,1,1,1,1,0,0,0,11,5,3,2,2,1,1,1,1,1,1,0,0,12,6,4,3,2,2,1,1,1,1,1,1, };
        private static readonly byte[] rem = new byte[] { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,2,2,2,2,2,2,2,2,2,2,0,0,1,0,3,3,3,3,3,3,3,3,3,0,0,0,1,0,4,4,4,4,4,4,4,4,0,0,1,2,1,0,5,5,5,5,5,5,5,0,0,0,0,2,1,0,6,6,6,6,6,6,0,0,1,1,3,2,1,0,7,7,7,7,7,0,0,0,2,0,3,2,1,0,8,8,8,8,0,0,1,0,1,4,3,2,1,0,9,9,9,0,0,0,1,2,0,4,3,2,1,0,10,10,0,0,1,2,3,1,5,4,3,2,1,0,11,0,0,0,0,0,2,0,5,4,3,2,1,0, };

        /// <summary>
        /// The numerical value of the <see cref="Z13"/>.
        /// </summary>
        public readonly int Value;

        /// <summary>
        /// Creates a <see cref="Z13"/>.
        /// </summary>
        public Z13(int value)
        {
            Value = value % 13;
            if (Value < 0) Value += 13;
        }

        private Z13(bool dummy, int value)
        { Value = value; }

        /// <summary>
        /// Explicitly converts a <see cref="Z13"/> to a <see cref="System.Int32"/>.
        /// </summary>
        public static explicit operator int(Z13 value)
        { return value.Value; }

        /// <summary>
        /// Implicitly converts a <see cref="System.Int32"/> to a <see cref="Z13"/>.
        /// </summary>
        public static implicit operator Z13(int value)
        { return new Z13(value); }

        /// <summary>
        /// Gets a string representation of this <see cref="Z13"/>.
        /// </summary>
        public override string ToString()
        { return Value.ToString(); }
        
        /// <summary>
        /// Gets the hash code.
        /// </summary>
        public override int GetHashCode()
        { return Value.GetHashCode(); }

        /// <summary>
        /// Equality test.
        /// </summary>
        public override bool Equals(object obj)
        { return obj is Z13 && Equals((Z13)obj); }

        /// <summary>
        /// Equality test.
        /// </summary>
        public bool Equals(Z13 other)
        { return Value == other.Value; }

        /// <summary>
        /// Equality operator.
        /// </summary>
        public static bool operator ==(Z13 a, Z13 b)
        { return a.Equals(b); }

        /// <summary>
        /// Inequality operator.
        /// </summary>
        public static bool operator !=(Z13 a, Z13 b)
        { return !a.Equals(b); }

        /// <summary>
        /// Addition operator.
        /// </summary>
        public static Z13 operator +(Z13 a, Z13 b)
        {
            var result = a.Value + b.Value;
            if (result >= 13) result -= 13;
            return new Z13(false, result);
        }

        /// <summary>
        /// Addition.
        /// </summary>
        public Z13 Add(Z13 other)
        {
            return this + other;
        }

        /// <summary>
        /// Subtraction operator.
        /// </summary>
        public static Z13 operator -(Z13 a, Z13 b)
        {
            var result = a.Value + b.Value;
            if (result < 0) result += 13;
            return new Z13(false, result);
        }

        /// <summary>
        /// Subtraction.
        /// </summary>
        public Z13 Subtract(Z13 other)
        {
            return this - other;
        }

        /// <summary>
        /// Negation operator.
        /// </summary>
        public static Z13 operator -(Z13 value)
        {
            if (value.Value == 0) return value;
            return new Z13(false, 13 - value.Value);
        }

        /// <summary>
        /// Multiplication operator.
        /// </summary>
        public static Z13 operator *(Z13 a, Z13 b)
        {
            return new Z13(false, mul[a.Value * 13 + b.Value]);
        }

        /// <summary>
        /// Multiplication.
        /// </summary>
        public Z13 Multiply(Z13 other)
        {
            return this * other;
        }

        /// <summary>
        /// Division operator.
        /// </summary>
        public static Z13 operator /(Z13 a, Z13 b)
        {
            return new Z13(false, div[a.Value * 13 + b.Value]);
        }

        /// <summary>
        /// Division.
        /// </summary>
        public Z13 Divide(Z13 other)
        {
            return this / other;
        }

        /// <summary>
        /// Modulo operator.
        /// </summary>
        public static Z13 operator %(Z13 a, Z13 b)
        {
            return new Z13(false, rem[a.Value * 13 + b.Value]);
        }

        /// <summary>
        /// Gets the remainder after division.
        /// </summary>
        public Z13 Modulo(Z13 other)
        {
            return this % other;
        }

        /// <summary>
        /// Division with remainder.
        /// </summary>
        public static Z13 DivRem(Z13 a, Z13 b, out Z13 r)
        {
            int index = a.Value * 13 + b.Value;
            r = new Z13(false, rem[index]);
            return new Z13(false, div[index]);
        }

        /// <summary>
        /// Multiplicative inverse.
        /// </summary>
        public Z13 Inverse()
        {
            return Inverse(this);
        }

        /// <summary>
        /// Multiplicative inverse.
        /// </summary>
        public static Z13 Inverse(Z13 value)
        {
            var result = inv[value.Value];
            if (result == 0) throw new DivideByZeroException();
            return new Z13(false, div[result]);
        }

        /// <summary>
        /// Integer exponentiation.
        /// </summary>
        public static Z13 Pow(Z13 value, int exponent)
        {
            if (exponent == 0) return 1;
            var result = 1;
            var b = value.Value;
            var e = Math.Abs(exponent);

            while (e > 0)
            {
                if ((e & 1) == 1)
                {
                    result = (result * b) % 13;
                }

                e >>= 1;
                b = (b * b) % 13;
            }

            if (exponent < 0) 
            {
                result = inv[result];
                if (result == 0) throw new DivideByZeroException();
            }

            return new Z13(false, result);
        }

    }

    /// <summary>
    /// Integer modulo 17.
    /// </summary>
    public struct Z17 : IEquatable<Z17>
    {
        private static readonly byte[] mul = new byte[] { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,0,2,4,6,8,10,12,14,16,1,3,5,7,9,11,13,15,0,3,6,9,12,15,1,4,7,10,13,16,2,5,8,11,14,0,4,8,12,16,3,7,11,15,2,6,10,14,1,5,9,13,0,5,10,15,3,8,13,1,6,11,16,4,9,14,2,7,12,0,6,12,1,7,13,2,8,14,3,9,15,4,10,16,5,11,0,7,14,4,11,1,8,15,5,12,2,9,16,6,13,3,10,0,8,16,7,15,6,14,5,13,4,12,3,11,2,10,1,9,0,9,1,10,2,11,3,12,4,13,5,14,6,15,7,16,8,0,10,3,13,6,16,9,2,12,5,15,8,1,11,4,14,7,0,11,5,16,10,4,15,9,3,14,8,2,13,7,1,12,6,0,12,7,2,14,9,4,16,11,6,1,13,8,3,15,10,5,0,13,9,5,1,14,10,6,2,15,11,7,3,16,12,8,4,0,14,11,8,5,2,16,13,10,7,4,1,15,12,9,6,3,0,15,13,11,9,7,5,3,1,16,14,12,10,8,6,4,2,0,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1, };
        private static readonly byte[] inv = new byte[] { 0,1,9,6,13,7,3,5,15,2,12,14,10,4,11,8,16, };
        private static readonly byte[] div = new byte[] { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,5,2,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,6,3,2,1,1,1,0,0,0,0,0,0,0,0,0,0,0,7,3,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,8,4,2,2,1,1,1,1,0,0,0,0,0,0,0,0,0,9,4,3,2,1,1,1,1,1,0,0,0,0,0,0,0,0,10,5,3,2,2,1,1,1,1,1,0,0,0,0,0,0,0,11,5,3,2,2,1,1,1,1,1,1,0,0,0,0,0,0,12,6,4,3,2,2,1,1,1,1,1,1,0,0,0,0,0,13,6,4,3,2,2,1,1,1,1,1,1,1,0,0,0,0,14,7,4,3,2,2,2,1,1,1,1,1,1,1,0,0,0,15,7,5,3,3,2,2,1,1,1,1,1,1,1,1,0,0,16,8,5,4,3,2,2,2,1,1,1,1,1,1,1,1, };
        private static readonly byte[] rem = new byte[] { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,1,0,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,1,0,4,4,4,4,4,4,4,4,4,4,4,4,0,0,1,2,1,0,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,2,1,0,6,6,6,6,6,6,6,6,6,6,0,0,1,1,3,2,1,0,7,7,7,7,7,7,7,7,7,0,0,0,2,0,3,2,1,0,8,8,8,8,8,8,8,8,0,0,1,0,1,4,3,2,1,0,9,9,9,9,9,9,9,0,0,0,1,2,0,4,3,2,1,0,10,10,10,10,10,10,0,0,1,2,3,1,5,4,3,2,1,0,11,11,11,11,11,0,0,0,0,0,2,0,5,4,3,2,1,0,12,12,12,12,0,0,1,1,1,3,1,6,5,4,3,2,1,0,13,13,13,0,0,0,2,2,4,2,0,6,5,4,3,2,1,0,14,14,0,0,1,0,3,0,3,1,7,6,5,4,3,2,1,0,15,0,0,0,1,0,1,4,2,0,7,6,5,4,3,2,1,0, };

        /// <summary>
        /// The numerical value of the <see cref="Z17"/>.
        /// </summary>
        public readonly int Value;

        /// <summary>
        /// Creates a <see cref="Z17"/>.
        /// </summary>
        public Z17(int value)
        {
            Value = value % 17;
            if (Value < 0) Value += 17;
        }

        private Z17(bool dummy, int value)
        { Value = value; }

        /// <summary>
        /// Explicitly converts a <see cref="Z17"/> to a <see cref="System.Int32"/>.
        /// </summary>
        public static explicit operator int(Z17 value)
        { return value.Value; }

        /// <summary>
        /// Implicitly converts a <see cref="System.Int32"/> to a <see cref="Z17"/>.
        /// </summary>
        public static implicit operator Z17(int value)
        { return new Z17(value); }

        /// <summary>
        /// Gets a string representation of this <see cref="Z17"/>.
        /// </summary>
        public override string ToString()
        { return Value.ToString(); }
        
        /// <summary>
        /// Gets the hash code.
        /// </summary>
        public override int GetHashCode()
        { return Value.GetHashCode(); }

        /// <summary>
        /// Equality test.
        /// </summary>
        public override bool Equals(object obj)
        { return obj is Z17 && Equals((Z17)obj); }

        /// <summary>
        /// Equality test.
        /// </summary>
        public bool Equals(Z17 other)
        { return Value == other.Value; }

        /// <summary>
        /// Equality operator.
        /// </summary>
        public static bool operator ==(Z17 a, Z17 b)
        { return a.Equals(b); }

        /// <summary>
        /// Inequality operator.
        /// </summary>
        public static bool operator !=(Z17 a, Z17 b)
        { return !a.Equals(b); }

        /// <summary>
        /// Addition operator.
        /// </summary>
        public static Z17 operator +(Z17 a, Z17 b)
        {
            var result = a.Value + b.Value;
            if (result >= 17) result -= 17;
            return new Z17(false, result);
        }

        /// <summary>
        /// Addition.
        /// </summary>
        public Z17 Add(Z17 other)
        {
            return this + other;
        }

        /// <summary>
        /// Subtraction operator.
        /// </summary>
        public static Z17 operator -(Z17 a, Z17 b)
        {
            var result = a.Value + b.Value;
            if (result < 0) result += 17;
            return new Z17(false, result);
        }

        /// <summary>
        /// Subtraction.
        /// </summary>
        public Z17 Subtract(Z17 other)
        {
            return this - other;
        }

        /// <summary>
        /// Negation operator.
        /// </summary>
        public static Z17 operator -(Z17 value)
        {
            if (value.Value == 0) return value;
            return new Z17(false, 17 - value.Value);
        }

        /// <summary>
        /// Multiplication operator.
        /// </summary>
        public static Z17 operator *(Z17 a, Z17 b)
        {
            return new Z17(false, mul[a.Value * 17 + b.Value]);
        }

        /// <summary>
        /// Multiplication.
        /// </summary>
        public Z17 Multiply(Z17 other)
        {
            return this * other;
        }

        /// <summary>
        /// Division operator.
        /// </summary>
        public static Z17 operator /(Z17 a, Z17 b)
        {
            return new Z17(false, div[a.Value * 17 + b.Value]);
        }

        /// <summary>
        /// Division.
        /// </summary>
        public Z17 Divide(Z17 other)
        {
            return this / other;
        }

        /// <summary>
        /// Modulo operator.
        /// </summary>
        public static Z17 operator %(Z17 a, Z17 b)
        {
            return new Z17(false, rem[a.Value * 17 + b.Value]);
        }

        /// <summary>
        /// Gets the remainder after division.
        /// </summary>
        public Z17 Modulo(Z17 other)
        {
            return this % other;
        }

        /// <summary>
        /// Division with remainder.
        /// </summary>
        public static Z17 DivRem(Z17 a, Z17 b, out Z17 r)
        {
            int index = a.Value * 17 + b.Value;
            r = new Z17(false, rem[index]);
            return new Z17(false, div[index]);
        }

        /// <summary>
        /// Multiplicative inverse.
        /// </summary>
        public Z17 Inverse()
        {
            return Inverse(this);
        }

        /// <summary>
        /// Multiplicative inverse.
        /// </summary>
        public static Z17 Inverse(Z17 value)
        {
            var result = inv[value.Value];
            if (result == 0) throw new DivideByZeroException();
            return new Z17(false, div[result]);
        }

        /// <summary>
        /// Integer exponentiation.
        /// </summary>
        public static Z17 Pow(Z17 value, int exponent)
        {
            if (exponent == 0) return 1;
            var result = 1;
            var b = value.Value;
            var e = Math.Abs(exponent);

            while (e > 0)
            {
                if ((e & 1) == 1)
                {
                    result = (result * b) % 17;
                }

                e >>= 1;
                b = (b * b) % 17;
            }

            if (exponent < 0) 
            {
                result = inv[result];
                if (result == 0) throw new DivideByZeroException();
            }

            return new Z17(false, result);
        }

    }

    /// <summary>
    /// Integer modulo 19.
    /// </summary>
    public struct Z19 : IEquatable<Z19>
    {
        private static readonly byte[] mul = new byte[] { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,0,2,4,6,8,10,12,14,16,18,1,3,5,7,9,11,13,15,17,0,3,6,9,12,15,18,2,5,8,11,14,17,1,4,7,10,13,16,0,4,8,12,16,1,5,9,13,17,2,6,10,14,18,3,7,11,15,0,5,10,15,1,6,11,16,2,7,12,17,3,8,13,18,4,9,14,0,6,12,18,5,11,17,4,10,16,3,9,15,2,8,14,1,7,13,0,7,14,2,9,16,4,11,18,6,13,1,8,15,3,10,17,5,12,0,8,16,5,13,2,10,18,7,15,4,12,1,9,17,6,14,3,11,0,9,18,8,17,7,16,6,15,5,14,4,13,3,12,2,11,1,10,0,10,1,11,2,12,3,13,4,14,5,15,6,16,7,17,8,18,9,0,11,3,14,6,17,9,1,12,4,15,7,18,10,2,13,5,16,8,0,12,5,17,10,3,15,8,1,13,6,18,11,4,16,9,2,14,7,0,13,7,1,14,8,2,15,9,3,16,10,4,17,11,5,18,12,6,0,14,9,4,18,13,8,3,17,12,7,2,16,11,6,1,15,10,5,0,15,11,7,3,18,14,10,6,2,17,13,9,5,1,16,12,8,4,0,16,13,10,7,4,1,17,14,11,8,5,2,18,15,12,9,6,3,0,17,15,13,11,9,7,5,3,1,18,16,14,12,10,8,6,4,2,0,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1, };
        private static readonly byte[] inv = new byte[] { 0,1,10,13,5,4,16,11,12,17,2,7,8,3,15,14,6,9,18, };
        private static readonly byte[] div = new byte[] { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,2,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,6,3,2,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,7,3,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,8,4,2,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,9,4,3,2,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,10,5,3,2,2,1,1,1,1,1,0,0,0,0,0,0,0,0,0,11,5,3,2,2,1,1,1,1,1,1,0,0,0,0,0,0,0,0,12,6,4,3,2,2,1,1,1,1,1,1,0,0,0,0,0,0,0,13,6,4,3,2,2,1,1,1,1,1,1,1,0,0,0,0,0,0,14,7,4,3,2,2,2,1,1,1,1,1,1,1,0,0,0,0,0,15,7,5,3,3,2,2,1,1,1,1,1,1,1,1,0,0,0,0,16,8,5,4,3,2,2,2,1,1,1,1,1,1,1,1,0,0,0,17,8,5,4,3,2,2,2,1,1,1,1,1,1,1,1,1,0,0,18,9,6,4,3,3,2,2,2,1,1,1,1,1,1,1,1,1, };
        private static readonly byte[] rem = new byte[] { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,1,0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,0,1,0,4,4,4,4,4,4,4,4,4,4,4,4,4,4,0,0,1,2,1,0,5,5,5,5,5,5,5,5,5,5,5,5,5,0,0,0,0,2,1,0,6,6,6,6,6,6,6,6,6,6,6,6,0,0,1,1,3,2,1,0,7,7,7,7,7,7,7,7,7,7,7,0,0,0,2,0,3,2,1,0,8,8,8,8,8,8,8,8,8,8,0,0,1,0,1,4,3,2,1,0,9,9,9,9,9,9,9,9,9,0,0,0,1,2,0,4,3,2,1,0,10,10,10,10,10,10,10,10,0,0,1,2,3,1,5,4,3,2,1,0,11,11,11,11,11,11,11,0,0,0,0,0,2,0,5,4,3,2,1,0,12,12,12,12,12,12,0,0,1,1,1,3,1,6,5,4,3,2,1,0,13,13,13,13,13,0,0,0,2,2,4,2,0,6,5,4,3,2,1,0,14,14,14,14,0,0,1,0,3,0,3,1,7,6,5,4,3,2,1,0,15,15,15,0,0,0,1,0,1,4,2,0,7,6,5,4,3,2,1,0,16,16,0,0,1,2,1,2,5,3,1,8,7,6,5,4,3,2,1,0,17,0,0,0,0,2,3,0,4,2,0,8,7,6,5,4,3,2,1,0, };

        /// <summary>
        /// The numerical value of the <see cref="Z19"/>.
        /// </summary>
        public readonly int Value;

        /// <summary>
        /// Creates a <see cref="Z19"/>.
        /// </summary>
        public Z19(int value)
        {
            Value = value % 19;
            if (Value < 0) Value += 19;
        }

        private Z19(bool dummy, int value)
        { Value = value; }

        /// <summary>
        /// Explicitly converts a <see cref="Z19"/> to a <see cref="System.Int32"/>.
        /// </summary>
        public static explicit operator int(Z19 value)
        { return value.Value; }

        /// <summary>
        /// Implicitly converts a <see cref="System.Int32"/> to a <see cref="Z19"/>.
        /// </summary>
        public static implicit operator Z19(int value)
        { return new Z19(value); }

        /// <summary>
        /// Gets a string representation of this <see cref="Z19"/>.
        /// </summary>
        public override string ToString()
        { return Value.ToString(); }
        
        /// <summary>
        /// Gets the hash code.
        /// </summary>
        public override int GetHashCode()
        { return Value.GetHashCode(); }

        /// <summary>
        /// Equality test.
        /// </summary>
        public override bool Equals(object obj)
        { return obj is Z19 && Equals((Z19)obj); }

        /// <summary>
        /// Equality test.
        /// </summary>
        public bool Equals(Z19 other)
        { return Value == other.Value; }

        /// <summary>
        /// Equality operator.
        /// </summary>
        public static bool operator ==(Z19 a, Z19 b)
        { return a.Equals(b); }

        /// <summary>
        /// Inequality operator.
        /// </summary>
        public static bool operator !=(Z19 a, Z19 b)
        { return !a.Equals(b); }

        /// <summary>
        /// Addition operator.
        /// </summary>
        public static Z19 operator +(Z19 a, Z19 b)
        {
            var result = a.Value + b.Value;
            if (result >= 19) result -= 19;
            return new Z19(false, result);
        }

        /// <summary>
        /// Addition.
        /// </summary>
        public Z19 Add(Z19 other)
        {
            return this + other;
        }

        /// <summary>
        /// Subtraction operator.
        /// </summary>
        public static Z19 operator -(Z19 a, Z19 b)
        {
            var result = a.Value + b.Value;
            if (result < 0) result += 19;
            return new Z19(false, result);
        }

        /// <summary>
        /// Subtraction.
        /// </summary>
        public Z19 Subtract(Z19 other)
        {
            return this - other;
        }

        /// <summary>
        /// Negation operator.
        /// </summary>
        public static Z19 operator -(Z19 value)
        {
            if (value.Value == 0) return value;
            return new Z19(false, 19 - value.Value);
        }

        /// <summary>
        /// Multiplication operator.
        /// </summary>
        public static Z19 operator *(Z19 a, Z19 b)
        {
            return new Z19(false, mul[a.Value * 19 + b.Value]);
        }

        /// <summary>
        /// Multiplication.
        /// </summary>
        public Z19 Multiply(Z19 other)
        {
            return this * other;
        }

        /// <summary>
        /// Division operator.
        /// </summary>
        public static Z19 operator /(Z19 a, Z19 b)
        {
            return new Z19(false, div[a.Value * 19 + b.Value]);
        }

        /// <summary>
        /// Division.
        /// </summary>
        public Z19 Divide(Z19 other)
        {
            return this / other;
        }

        /// <summary>
        /// Modulo operator.
        /// </summary>
        public static Z19 operator %(Z19 a, Z19 b)
        {
            return new Z19(false, rem[a.Value * 19 + b.Value]);
        }

        /// <summary>
        /// Gets the remainder after division.
        /// </summary>
        public Z19 Modulo(Z19 other)
        {
            return this % other;
        }

        /// <summary>
        /// Division with remainder.
        /// </summary>
        public static Z19 DivRem(Z19 a, Z19 b, out Z19 r)
        {
            int index = a.Value * 19 + b.Value;
            r = new Z19(false, rem[index]);
            return new Z19(false, div[index]);
        }

        /// <summary>
        /// Multiplicative inverse.
        /// </summary>
        public Z19 Inverse()
        {
            return Inverse(this);
        }

        /// <summary>
        /// Multiplicative inverse.
        /// </summary>
        public static Z19 Inverse(Z19 value)
        {
            var result = inv[value.Value];
            if (result == 0) throw new DivideByZeroException();
            return new Z19(false, div[result]);
        }

        /// <summary>
        /// Integer exponentiation.
        /// </summary>
        public static Z19 Pow(Z19 value, int exponent)
        {
            if (exponent == 0) return 1;
            var result = 1;
            var b = value.Value;
            var e = Math.Abs(exponent);

            while (e > 0)
            {
                if ((e & 1) == 1)
                {
                    result = (result * b) % 19;
                }

                e >>= 1;
                b = (b * b) % 19;
            }

            if (exponent < 0) 
            {
                result = inv[result];
                if (result == 0) throw new DivideByZeroException();
            }

            return new Z19(false, result);
        }

    }

}
