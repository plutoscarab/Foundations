
/*
ValueTypes.cs

Copyright © 2016 Pluto Scarab Software. Most Rights Reserved.
Author: Bret Mulvey

This work is licensed under the Creative Commons Attribution-ShareAlike 4.0 International License. 
To view a copy of this license, visit http://creativecommons.org/licenses/by-sa/4.0/.

THIS IS AN AUTO-GENERATED SOURCE FILE. DO NOT EDIT THIS FILE DIRECTLY.
INSTEAD, EDIT THE .tt FILE WITH THE SAME NAME AND RE-RUN THE TEXT TEMPLATING
FILE GENERATOR. IF YOU SAVE THE FILE IN VISUAL STUDIO IT WILL DO THIS FOR YOU.
*/

using System;

namespace Foundations.Types
{
    /// <summary>
    /// An integer power of a factor.
    /// </summary>
	public partial struct Factor<T> : IEquatable<Factor<T>>
	{
		/// <summary>The factor.</summary>
		public readonly T Value;

		/// <summary>Exponent of the factor.</summary>
		public readonly int Exponent;

		/// <summary>Create an instance of <see cref="Factor{T}"/>.</summary>
		public Factor(T value, int exponent)
		{
			Value = value;
			Exponent = exponent;
		}

		/// <summary>Implementation of <see	cref="object.GetHashCode"/>.</summary>
		public override int GetHashCode()
		{
			int h = -829975572;
			h = HashHelper.Mixer(h + Value.GetHashCode());
			h = HashHelper.Mixer(h + Exponent.GetHashCode());
			return h;
		}

		/// <summary>Implementation of <see cref="object.Equals(object)"/>.</summary>
		public override bool Equals(object obj)
		{
			return obj is Factor<T> && Equals((Factor<T>)obj);
		}

		/// <summary>Implementation of <see cref="IEquatable{U}.Equals"/>.</summary>
		public bool Equals(Factor<T> other)
		{
			if (!Value.Equals(other.Value)) return false;
			if (!Exponent.Equals(other.Exponent)) return false;
			return true;
		}

		/// <summary>Equality operator.</summary>
		public static bool operator ==(Factor<T> a, Factor<T> b)
		{
			return a.Equals(b);
		}

		/// <summary>Inequality operator.</summary>
		public static bool operator !=(Factor<T> a, Factor<T> b)
		{
			return !a.Equals(b);
		}
	}


	public partial struct SmallDegreePolyGF2 : IEquatable<SmallDegreePolyGF2>
	{
		/// <summary>The coefficients of the polynomial.</summary>
		public readonly ulong Coefficients;

		/// <summary>Create an instance of <see cref="SmallDegreePolyGF2"/>.</summary>
		public SmallDegreePolyGF2(ulong coefficients)
		{
			Coefficients = coefficients;
		}

		/// <summary>Implementation of <see	cref="object.GetHashCode"/>.</summary>
		public override int GetHashCode()
		{
			int h = 1588331146;
			h = HashHelper.Mixer(h + Coefficients.GetHashCode());
			return h;
		}

		/// <summary>Implementation of <see cref="object.Equals(object)"/>.</summary>
		public override bool Equals(object obj)
		{
			return obj is SmallDegreePolyGF2 && Equals((SmallDegreePolyGF2)obj);
		}

		/// <summary>Implementation of <see cref="IEquatable{U}.Equals"/>.</summary>
		public bool Equals(SmallDegreePolyGF2 other)
		{
			if (!Coefficients.Equals(other.Coefficients)) return false;
			return true;
		}

		/// <summary>Equality operator.</summary>
		public static bool operator ==(SmallDegreePolyGF2 a, SmallDegreePolyGF2 b)
		{
			return a.Equals(b);
		}

		/// <summary>Inequality operator.</summary>
		public static bool operator !=(SmallDegreePolyGF2 a, SmallDegreePolyGF2 b)
		{
			return !a.Equals(b);
		}
	}

	internal static class HashHelper
	{
		public static Func<int, int> Mixer = Functions.MixingFunctions.CreateInt32Mixer(new[] { 0, 1, 1, 8, 9, 9, 9, 8, 8, 1, 9, 9, 9, 1, 1, 9, 7, 2, 5, 3 });
	}
}
