<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="../../TemplateFilemanager.CS.ttinclude" #>
<#
var manager = TemplateFileManager.Create(this);

for (int i = minNW; i <= maxNW; i += incNW)
{
    manager.StartNewFile($"Fixed{i}p{32 - i}.cs");
#>

/*
Fixed<#= i #>p<#= 32 - i #>.cs

<#@ include file="../../License.txt" #>
*/

using System;
using System.Globalization;
using Foundations.RandomNumbers;

namespace Foundations.Types
{
<# Make(i, 32, "int"); #>
}<#
}

manager.Process();
#>
<#+
const int minNW = 4;
const int maxNW = 28;
const int incNW = 4;

void Make(int nw, int bits, string t)
{
    int nf = bits - nw;
    var T = $"Fixed{nw}p{nf}";
    var incr = .5m / (1L << (nf - 1));
    var mv = bits == 16 ? short.MinValue : bits == 32 ? int.MinValue : long.MinValue;
    var min = (decimal)(-1);
    for (int i = 0; i < nw - 1; i++) min *= 2;
    var max = -min - incr;
    var t2 = bits == 16 ? "int" : bits == 32 ? "long" : "decimal";
#>
    /// <summary>
    /// Signed <#= bits #>-bit number with <#= nf #> fractional bit<#= nf == 1 ? "" : "s" #> and <#= nw #> integer bit<#= nw == 1 ? "" : "s" #>.
    /// Represents values from <#= min #> to <#= max #> in increments of <#= incr #>.
    /// </summary>
    public partial struct <#= T #> : IEquatable<<#= T #>>, IComparable<<#= T #>>
    {
        /// <summary>
        /// The constant value 0.
        /// </summary>
        public static readonly <#= T #> Zero = new <#= T #>(0);

<#+ if (nw > 1) { #>
        /// <summary>
        /// The constant value 1.
        /// </summary>
        public static readonly <#= T #> One = new <#= T #>(<#= 1L << nf #>);

<#+ } #>
        /// <summary>
        /// The constant value <#= min #>.
        /// </summary>
        public static readonly <#= T #> MinValue = new <#= T #>(<#= t #>.MinValue);

        /// <summary>
        /// The constant value <#= max #>.
        /// </summary>
        public static readonly <#= T #> MaxValue = new <#= T #>(<#= t #>.MaxValue);

        /// <summary>
        /// The constant value <#= incr #>.
        /// </summary>
        public static readonly <#= T #> ε = new <#= T #>(1);

        /// <summary>PI</summary>
        public static readonly <#= T #> π          = (<#= T #>)3.1415926535897932384626433833;

        /// <summary>Base of natural logarithm.</summary>
        public static readonly <#= T #> e          = (<#= T #>)2.7182818284590452353602874714;

        /// <summary>Golden ratio.</summary>
        public static readonly <#= T #> φ          = (<#= T #>)1.6180339887498948482045868344;

        /// <summary>Euler–Mascheroni constant.</summary>
        public static readonly <#= T #> γ          = (<#= T #>)0.5772156649015328606065120901;

        /// <summary>Square root of 2π.</summary>
        public static readonly <#= T #> Sqrt2π     = (<#= T #>)2.5066282746310005024157652848;

        /// <summary>Square root of 5.</summary>
        public static readonly <#= T #> Sqrt5      = (<#= T #>)2.2360679774997896964091736687;

        /// <summary>Square root of π.</summary>
        public static readonly <#= T #> Sqrtπ      = (<#= T #>)1.7724538509055160272981674833;

        /// <summary>Square root of 3.</summary>
        public static readonly <#= T #> Sqrt3      = (<#= T #>)1.7320508075688772935274463415;

        /// <summary>Square root of 2.</summary>
        public static readonly <#= T #> Sqrt2      = (<#= T #>)1.4142135623730950488016887242;

        /// <summary>Square root of π/2.</summary>
        public static readonly <#= T #> SqrtHalfπ  = (<#= T #>)1.2533141373155002512078826424;

        /// <summary>Base-2 logarithm of 10.</summary>
        public static readonly <#= T #> Lg10       = (<#= T #>)3.3219280948873623478703194295;
   
        /// <summary>Natural logarithm of 10.</summary>
        public static readonly <#= T #> Ln10       = (<#= T #>)2.3025850929940456840179914547;

        /// <summary>Base-2 logarithm of e.</summary>
        public static readonly <#= T #> LgE        = (<#= T #>)1.4426950408889634073599246810;
   
        /// <summary>Natural logarithm of 2.</summary>
        public static readonly <#= T #> Ln2        = (<#= T #>)0.6931471805599453094172321215;

        /// <summary>Base-10 logarithm of e.</summary>
        public static readonly <#= T #> LogE       = (<#= T #>)0.4342944819032518276511289189;

        /// <summary>Base-10 logarithm of 2.</summary>
        public static readonly <#= T #> Log2       = (<#= T #>)0.3010299956639811952137388947;

        internal readonly <#= t #> value;

        private <#= T #>(<#= t #> value)
        {
            this.value = value;
        }

        /// <summary>
        /// Parses a string representation of a <see cref="<#= T #>"/>.
        /// </summary>
        public static <#= T #> Parse(string s)
        {
            var d = double.Parse(s);
            return new <#= T #>((<#= t #>)(d * <#= 1L << nf #>d + .5d * Math.Sign(d)));
        }

        /// <summary>
        /// Parses a string representation of a <see cref="<#= T #>"/>.
        /// </summary>
        public static <#= T #> Parse(string s, IFormatProvider provider)
        {
            var d = double.Parse(s, provider);
            return new <#= T #>((<#= t #>)(d * <#= 1L << nf #>d + .5d * Math.Sign(d)));
        }

        /// <summary>
        /// Parses a string representation of a <see cref="<#= T #>"/>.
        /// </summary>
        public static <#= T #> Parse(string s, NumberStyles style)
        {
            var d = double.Parse(s, style);
            return new <#= T #>((<#= t #>)(d * <#= 1L << nf #>d + .5d * Math.Sign(d)));
        }

        /// <summary>
        /// Parses a string representation of a <see cref="<#= T #>"/>.
        /// </summary>
        public static <#= T #> Parse(string s, NumberStyles style, IFormatProvider provider)
        {
            var d = double.Parse(s, style, provider);
            return new <#= T #>((<#= t #>)(d * <#= 1L << nf #>d + .5d * Math.Sign(d)));
        }

        /// <summary>
        /// Tries to parse a string representation of a <see cref="<#= T #>"/>.
        /// </summary>
        public static bool TryParse(string s, out <#= T #> result)
        {
            double d;
            
            if (!double.TryParse(s, out d))
            {
                result = Zero;
                return false;
            }

            result = new <#= T #>((<#= t #>)(d * <#= 1L << nf #>d + .5d * Math.Sign(d)));
            return true;
        }

        /// <summary>
        /// Tries to parse a string representation of a <see cref="<#= T #>"/>.
        /// </summary>
        public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out <#= T #> result)
        {
            double d;
            
            if (!double.TryParse(s, style, provider, out d))
            {
                result = Zero;
                return false;
            }

            result = new <#= T #>((<#= t #>)(d * <#= 1L << nf #>d + .5d * Math.Sign(d)));
            return true;
        }

        /// <summary>
        /// Implementation of <see cref="object.ToString"/>.
        /// </summary>
        public override string ToString()
        {
            return (value * <#= incr #>d).ToString();
        }

        /// <summary>
        /// Gets a string representation of this <see cref="<#= T #>"/>.
        /// </summary>
        public string ToString(string format)
        {
            return (value * <#= incr #>d).ToString(format);
        }

        /// <summary>
        /// Gets a string representation of this <see cref="<#= T #>"/>.
        /// </summary>
        public string ToString(IFormatProvider provider)
        {
            return (value * <#= incr #>d).ToString(provider);
        }

        /// <summary>
        /// Gets a string representation of this <see cref="<#= T #>"/>.
        /// </summary>
        public string ToString(string format, IFormatProvider provider)
        {
            return (value * <#= incr #>d).ToString(format, provider);
        }

        /// <summary>
        /// Explicitly converts a <see cref="Decimal"/> to a <#= T #>.
        /// </summary>
        public static explicit operator <#= T #>(decimal value)
        {
            if (value < <#= min #>m || value > <#= max #>m) throw new ArgumentOutOfRangeException();
            return new <#= T #>((<#= t #>)(value * <#= 1L << nf #>m + .5m * Math.Sign(value)));
        }

        /// <summary>
        /// Implicitly converts a <#= T #> to a <see cref="Decimal"/>.
        /// </summary>
        public static implicit operator decimal(<#= T #> value)
        {
            return value.value * <#= incr #>m;
        }

        /// <summary>
        /// <#= bits < 52 ? "Explicitly" : "Implicitly" #> converts a <see cref="Double"/> to a <#= T #>.
        /// </summary>
        public static <#= bits < 52 ? "explicit" : "implicit" #> operator <#= T #>(double value)
        {
<#+ if (bits < 52) {#>
            if (value < <#= min #>d || value > <#= max #>d) throw new ArgumentOutOfRangeException();
<#+ } #>
            return new <#= T #>((<#= t #>)(value * <#= 1L << nf #>d + .5d * Math.Sign(value)));
        }

        /// <summary>
        /// <#= bits < 52 ? "Implicitly" : "Explicitly" #> converts a <#= T #> to a <see cref="Double"/>.
        /// </summary>
        public static <#= bits < 52 ? "implicit" : "explicit" #> operator double(<#= T #> value)
        {
            return value.value * <#= incr #>d;
        }

        /// <summary>
        /// <#= bits < 23 ? "Implicitly" : "Explicitly" #> converts a <#= T #> to a <see cref="Single"/>.
        /// </summary>
        public static <#= bits < 23 ? "implicit" : "explicit" #> operator float(<#= T #> value)
        {
            return value.value * <#= incr #>f;
        }

        /// <summary>
        /// Implicitly converts a <see cref="Int64"/> to a <#= T #>.
        /// </summary>
        public static implicit operator <#= T #>(long value)
        {
            return new <#= T #>((<#= t #>)(value << <#= nf #>));
        }

        /// <summary>
        /// Explicitly converts a <#= T #> to a <see cref="System.Int64"/>.
        /// </summary>
        public static explicit operator long(<#= T #> value)
        {
            return (long)(value.value >> <#= nf #>);
        }

        /// <summary>
        /// Explicitly converts a <#= T #> to a <see cref="System.UInt64"/>.
        /// </summary>
        public static explicit operator ulong(<#= T #> value)
        {
            return (ulong)(value.value >> <#= nf #>);
        }

        /// <summary>
        /// Explicitly converts a <#= T #> to a <see cref="System.Int32"/>.
        /// </summary>
        public static explicit operator int(<#= T #> value)
        {
            return (int)(value.value >> <#= nf #>);
        }

        /// <summary>
        /// Explicitly converts a <#= T #> to a <see cref="System.UInt32"/>.
        /// </summary>
        public static explicit operator uint(<#= T #> value)
        {
            return (uint)(value.value >> <#= nf #>);
        }

        /// <summary>
        /// Explicitly converts a <#= T #> to a <see cref="System.Int16"/>.
        /// </summary>
        public static explicit operator short(<#= T #> value)
        {
            return (short)(value.value >> <#= nf #>);
        }

        /// <summary>
        /// Explicitly converts a <#= T #> to a <see cref="System.UInt16"/>.
        /// </summary>
        public static explicit operator ushort(<#= T #> value)
        {
            return (ushort)(value.value >> <#= nf #>);
        }

        /// <summary>
        /// Explicitly converts a <#= T #> to a <see cref="System.SByte"/>.
        /// </summary>
        public static explicit operator sbyte(<#= T #> value)
        {
            return (sbyte)(value.value >> <#= nf #>);
        }

        /// <summary>
        /// Explicitly converts a <#= T #> to a <see cref="System.Byte"/>.
        /// </summary>
        public static explicit operator byte(<#= T #> value)
        {
            return (byte)(value.value >> <#= nf #>);
        }

        /// <summary>
        /// Implementation of <see cref="object.Equals(object)"/>.
        /// </summary>
        public override bool Equals(object obj)
        {
            return obj is <#= T #> && Equals((<#= T #>)obj);
        }

        /// <summary>
        /// Implementation of <see cref="IEquatable{<#= T #>}"/>.
        /// </summary>
        public bool Equals(<#= T #> other)
        {
            return value == other.value;
        }

        /// <summary>
        /// Equality operator.
        /// </summary>
        public static bool operator ==(<#= T #> a, <#= T #> b)
        {
            return a.value == b.value;
        }

        /// <summary>
        /// Inequality operator.
        /// </summary>
        public static bool operator !=(<#= T #> a, <#= T #> b)
        {
            return a.value != b.value;
        }

        /// <summary>
        /// Implementation of <see cref="object.GetHashCode"/>.
        /// </summary>
        public override int GetHashCode()
        {
            return value<#= bits == 32 ? "" : ".GetHashCode()" #> ^ <#= T.GetHashCode() #>;
        }

        /// <summary>
        /// Less-than operator.
        /// </summary>
        public static bool operator <(<#= T #> a, <#= T #> b)
        {
            return a.value < b.value;
        }

        /// <summary>
        /// Greater-than operator.
        /// </summary>
        public static bool operator >(<#= T #> a, <#= T #> b)
        {
            return a.value > b.value;
        }

        /// <summary>
        /// Less-than-or-equal operator.
        /// </summary>
        public static bool operator <=(<#= T #> a, <#= T #> b)
        {
            return a.value <= b.value;
        }

        /// <summary>
        /// Greater-than-or-equal operator.
        /// </summary>
        public static bool operator >=(<#= T #> a, <#= T #> b)
        {
            return a.value >= b.value;
        }

        /// <summary>
        /// Implementation of <see cref="IComparable{<#= T #>}"/>.
        /// </summary>
        public int CompareTo(<#= T #> other)
        {
            return value.CompareTo(other.value);
        }

        /// <summary>
        /// Right-shift operator.
        /// </summary>
        public static <#= T #> operator >>(<#= T #> value, int shift)
        {
            return new <#= T #>((<#= t #>)(value.value >> shift));
        }

        /// <summary>
        /// Left-shift operator.
        /// </summary>
        public static <#= T #> operator <<(<#= T #> value, int shift)
        {
            return new <#= T #>((<#= t #>)(value.value << shift));
        }

        /// <summary>
        /// Gets the underlying bits that represent this <see cref="<#= T #>"/>.
        /// </summary>
        public static <#= t #> ToInt<#= bits #>Bits(<#= T #> value)
        {
            return value.value;
        }

        /// <summary>
        /// Creates a <see cref="<#= T #>"/> from the underlying bit representation.
        /// </summary>
        public static <#= T #> FromInt<#= bits #>Bits(<#= t #> value)
        {
            return new <#= T #>(value);
        }

        /// <summary>
        /// Unary plus operator.
        /// </summary>
        public static <#= T #> operator +(<#= T #> value)
        {
            return value;
        }

        /// <summary>
        /// Unary minus operator.
        /// </summary>
        public static <#= T #> operator -(<#= T #> value)
        {
            return new <#= T #>((<#= t #>)(-value.value));
        }

        /// <summary>
        /// Increment operator.
        /// </summary>
        public static <#= T #> operator ++(<#= T #> value)
        {
            return value + One;
        }

        /// <summary>
        /// Decrement operator.
        /// </summary>
        public static <#= T #> operator --(<#= T #> value)
        {
            return value - One;
        }

        /// <summary>
        /// Addition operator.
        /// </summary>
        public static <#= T #> operator +(<#= T #> a, <#= T #> b)
        {
            return new <#= T #>((<#= t #>)(a.value + b.value));
        }

        /// <summary>
        /// Subtraction operator.
        /// </summary>
        public static <#= T #> operator -(<#= T #> a, <#= T #> b)
        {
            return new <#= T #>((<#= t #>)(a.value - b.value));
        }

        /// <summary>
        /// Multiplication operator.
        /// </summary>
        public static <#= T #> operator *(<#= T #> a, <#= T #> b)
        {
            return new <#= T #>((<#= t #>)(((<#= t2 #>)a.value * (<#= t2 #>)b.value + ((<#= t2 #>)1 << <#= nf - 1 #>)) >> <#= nf #>));
        }

        /// <summary>
        /// Division operator.
        /// </summary>
        public static <#= T #> operator /(<#= T #> a, <#= T #> b)
        {
            return new <#= T #>((<#= t #>)((((<#= t2 #>)a.value << <#= bits #>) / b.value) >> <#= nw #>));
        }
<#+
for (int i = minNW; i <= maxNW; i += incNW) Cast(i, bits, T, t, nf);
#>

        /// <summary>
        /// Gets the absolute value of a <see cref="<#= T #>"/>.
        /// </summary>
        public static <#= T #> Abs(<#= T #> value)
        {
            return new <#= T #>(Math.Abs(value.value));
        }

        /// <summary>
        /// Gets the absolute value of this <see cref="<#= T #>"/>.
        /// </summary>
        public <#= T #> Abs()
        {
            return new <#= T #>(Math.Abs(value));
        }

        /// <summary>
        /// Gets the greatest integer <see cref="<#= T #>"/> that is not greater than the specified value.
        /// </summary>
        public static <#= T #> Floor(<#= T #> value)
        {
            return new <#= T #>((<#= t #>)(value.value & 0x<#= (~((1L << nf) - 1)).ToString("X").Substring(16 - bits / 4, bits / 4) #>));
        }

        /// <summary>
        /// Gets the greatest integer <see cref="<#= T #>"/> that is not greater than this value.
        /// </summary>
        public <#= T #> Floor()
        {
            return new <#= T #>((<#= t #>)(value & 0x<#= (~((1L << nf) - 1)).ToString("X").Substring(16 - bits / 4, bits / 4) #>));
        }

        /// <summary>
        /// Gets the least integer <see cref="<#= T #>"/> that is not less than the specified value.
        /// </summary>
        public static <#= T #> Ceiling(<#= T #> value)
        {
            return new <#= T #>((<#= t #>)((value.value + 0x<#= (((1L << nf) - 1)).ToString("X") #>) & 0x<#= (~((1L << nf) - 1)).ToString("X").Substring(16 - bits / 4, bits / 4) #>));
        }

        /// <summary>
        /// Gets the least integer <see cref="<#= T #>"/> that is not less than this value.
        /// </summary>
        public <#= T #> Ceiling()
        {
            return new <#= T #>((<#= t #>)((value + 0x<#= (((1L << nf) - 1)).ToString("X") #>) & 0x<#= (~((1L << nf) - 1)).ToString("X").Substring(16 - bits / 4, bits / 4) #>));
        }

        /// <summary>
        /// Gets the nearest integer <see cref="<#= T #>"/> to the specified value.
        /// </summary>
        public static <#= T #> Round(<#= T #> value)
        {
            return new <#= T #>((<#= t #>)((value.value + 0x<#= ((1L << (nf - 1))).ToString("X") #>) & 0x<#= (~((1L << nf) - 1)).ToString("X").Substring(16 - bits / 4, bits / 4) #>));
        }

        /// <summary>
        /// Gets the nearest integer <see cref="<#= T #>"/> to this value.
        /// </summary>
        public <#= T #> Round()
        {
            return new <#= T #>((<#= t #>)((value + 0x<#= ((1L << (nf - 1))).ToString("X") #>) & 0x<#= (~((1L << nf) - 1)).ToString("X").Substring(16 - bits / 4, bits / 4) #>));
        }

        /// <summary>
        /// Gets the fractional portion of a <see cref="<#= T #>"/>.
        /// </summary>
        public static <#= T #> Frac(<#= T #> value)
        {
            return new <#= T #>((<#= t #>)(Math.Abs(value.value) & 0x<#= (((1L << nf) - 1)).ToString("X") #>));
        }

        /// <summary>
        /// Gets the fractional portion of this <see cref="<#= T #>"/>.
        /// </summary>
        public <#= T #> Frac()
        {
            return new <#= T #>((<#= t #>)(Math.Abs(value) & 0x<#= (((1L << nf) - 1)).ToString("X") #>));
        }

        /// <summary>
        /// Rounds a <see cref="<#= T #>"/> toward zero.
        /// </summary>
        public static <#= T #> Truncate(<#= T #> value)
        {
            return value.value >= 0 ? Floor(value) : Ceiling(value);
        }

        /// <summary>
        /// Rounds this <see cref="<#= T #>"/> toward zero.
        /// </summary>
        public <#= T #> Truncate()
        {
            return value >= 0 ? Floor() : Ceiling();
        }

        /// <summary>
        /// Gets the sign of a <see cref="<#= T #>"/>.
        /// </summary>
        public static int Sign(<#= T #> value)
        {
            return Math.Sign(value.value);
        }

        /// <summary>
        /// Gets the sign of this <see cref="<#= T #>"/>.
        /// </summary>
        public int Sign()
        {
            return Math.Sign(value);
        }

        /// <summary>
        /// Gets the lesser of two <see cref="<#= T #>"/> values.
        /// </summary>
        public static <#= T #> Min(<#= T #> a, <#= T #> b)
        {
            return a.value < b.value ? a : b;
        }

        /// <summary>
        /// Gets the greater of two <see cref="<#= T #>"/> values.
        /// </summary>
        public static <#= T #> Max(<#= T #> a, <#= T #> b)
        {
            return a.value > b.value ? a : b;
        }
<#+
    foreach (var method in typeof(Math).GetMethods().Where(m => m.IsStatic).OrderBy(m => m.Name)
        .GroupBy(m => m.Name)
        .Where(m => m.Count() == 1 && m.First().GetParameters().Count() == 1 && m.First().GetParameters().First().ParameterType.Name == "Double"))
    {
#>

        /// <summary>
        /// <#= method.Key #> function.
        /// </summary>
        public static <#= T #> <#= method.Key #>(<#= T #> x) => (<#= T #>)Math.<#= method.Key #>((double)x);

        /// <summary>
        /// <#= method.Key #> function.
        /// </summary>
        public <#= T #> <#= method.Key #>() => (<#= T #>)Math.<#= method.Key #>((double)this);
<#+
    }
#>

        /// <summary>
        /// Gets a random <see cref="<#= T #>"/> from 0 (inclusive) to 1 (exclusive).
        /// </summary>
        public static <#= T #> Random(Generator g)
        {
            return new <#= T #>(g.Int32(<#= 1L << nf #>));
        }
    }
<#+
}

void Cast(int nw, int bits, string T, string t, int tf)
{
    int nf = bits - nw;
    var T2 = $"Fixed{nw}p{nf}";
    if (T == T2) return;
#>

        /// <summary>
        /// Explicitly cast a <see cref="<#= T2 #>"/> to a <see cref="<#= T #>"/>.
        /// </summary>
        public static explicit operator <#= T #>(<#= T2 #> other)
        {
<#+ 
    if (nf < tf) 
    { 
        switch (t)
        {
            case "short":
#>
            if (other.value < <#= short.MinValue >> (tf - nf) #> || other.value > <#= short.MaxValue >> (tf - nf) #>) throw new ArgumentOutOfRangeException();
<#+
                break;

            case "int":
#>
            if (other.value < <#= int.MinValue >> (tf - nf) #> || other.value > <#= int.MaxValue >> (tf - nf) #>) throw new ArgumentOutOfRangeException();
<#+
                break;

            case "long":
#>
            if (other.value < <#= long.MinValue >> (tf - nf) #> || other.value > <#= long.MaxValue >> (tf - nf) #>) throw new ArgumentOutOfRangeException();
<#+
                break;
        }
    }
#>
            return new <#= T #>((<#= t #>)(other.value <#= nf > tf ? ">>" : "<<" #> <#= Math.Abs(nf - tf) #>));
        }
<#+
}
#>