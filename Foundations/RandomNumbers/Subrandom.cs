
/*
Subrandom.cs

Copyright © 2016 Pluto Scarab Software. Most Rights Reserved.
Author: Bret Mulvey

This work is licensed under the Creative Commons Attribution-ShareAlike 4.0 International License. 
To view a copy of this license, visit http://creativecommons.org/licenses/by-sa/4.0/.

THIS IS AN AUTO-GENERATED SOURCE FILE. DO NOT EDIT THIS FILE DIRECTLY.
INSTEAD, EDIT THE .tt FILE WITH THE SAME NAME AND RE-RUN THE TEXT TEMPLATING
FILE GENERATOR. IF YOU SAVE THE FILE IN VISUAL STUDIO IT WILL DO THIS FOR YOU.
*/

using System;
using System.Collections.Generic;
using System.Linq;

namespace Foundations.RandomNumbers
{
    /// <summary>
    /// Low-discrepency sequences, a.k.a. subrandom or quasirandom numbers.
    /// </summary>
    public static class Subrandom
    {
        /// <summary>
        /// Additive recurrence, sₙ = (s₀ + αn) mod 1.
        /// </summary>
        /// <param name="s0">Value from 0 to 1 exclusive.</param>
        /// <param name="α">Value from 0 to 1 exclusive.</param>
	    public static IEnumerable<Double> AdditiveRecurrence(Double s0, Double α)
        {
            if (s0 <= 0 || s0 >= 1) throw new ArgumentOutOfRangeException(nameof(s0));
            if (α <= 0 || α >= 1) throw new ArgumentOutOfRangeException(nameof(α));
            var s = s0;

            while (true)
            {
                yield return s;
                s += α;
                if (s >= 1) s -= 1;
            }
        }

        /// <summary>
        /// Additive recurrence, sₙ = (α + αn) mod 1.
        /// </summary>
        /// <param name="α">Value from 0 to 1 exclusive.</param>
	    public static IEnumerable<Double> AdditiveRecurrence(Double α)
        {
            return AdditiveRecurrence(α, α);
        }

        /// <summary>
        /// Additive recurrence sₙ = (s₀ + αn) mod 1 with random s₀ and algebraic α of degree 2
        /// using specified random number generator.
        /// </summary>
	    public static IEnumerable<Double> AdditiveRecurrenceD(Generator generator)
        {
            if (generator == null) throw new ArgumentNullException();

            return AdditiveRecurrence(generator.Double(), (Double)
                generator.UInt64s()
                    .Select(u => Math.Sqrt(u))
                    .Select(f => f - Math.Floor(f))
                    .First(f => f > 0.3D && f < 0.7D));
        }

        /// <summary>
        /// Additive recurrence sₙ = (s₀ + αn) mod 1 with random s₀ and algebraic α of degree 2
        /// using default random number generator.
        /// </summary>
	    public static IEnumerable<Double> AdditiveRecurrenceD()
        {
            return AdditiveRecurrenceD(new Generator());
        }

        /// <summary>
        /// Van der Corput sequence.
        /// </summary>
        public static IEnumerable<Double> VanDerCorputD(int @base)
        {
            if (@base < 2) throw new ArgumentOutOfRangeException();
            var digits = new int[1];
            long denom = @base;

            while (true)
            {
                int i = 0;
                long num = 0;

                while (true)
                {
                    num = num * @base + ++digits[i];
                    if (digits[i] < @base) break;
                    digits[i] = 0;
                    num -= @base;
                    i++;

                    if (i >= digits.Length)
                    {
                        Array.Resize(ref digits, digits.Length + 1);
                        denom *= @base;
                    }
                }

                while (++i < digits.Length)
                {
                    num = num * @base + digits[i];
                }

                yield return num / (Double)denom;
            }
        }

        /// <summary>
        /// Halton sequence.
        /// </summary>
        public static IEnumerable<Double[]> HaltonD(int[] bases)
        {
            if (bases == null) throw new ArgumentNullException();
            if (bases.Length == 0) throw new ArgumentException();

            for (int i = 1; i < bases.Length; i++)
            {
                for (int j = 0; j < i; j++)
                {
                    int gcd = Numbers.GCD(bases[i], bases[j]);

                    if (gcd != 1)
                    {
                        throw new ArgumentException($"Values must be coprime. {bases[i]} and {bases[j]} share a factor of {gcd}.");
                    }
                }
            }

            var s = bases.Select(b => VanDerCorputD(b).GetEnumerator()).ToArray();
            var x = new Double[bases.Length];

            while (true)
            {
                for (int i = 0; i < bases.Length; i++)
                {
                    s[i].MoveNext();
                    x[i] = s[i].Current;
                }

                yield return x;
            }
        }

        /// <summary>
        /// Halton sequence.
        /// </summary>
        public static IEnumerable<Double[]> HaltonD(int dimension)
        {
            if (dimension < 0) throw new ArgumentOutOfRangeException();
            return HaltonD(Sequences.Primes().Select(_ => (int)_).Take(dimension).ToArray());
        }

        /// <summary>
        /// Hammersley set.
        /// </summary>
        public static IEnumerable<Double[]> HammersleyD(int[] bases, int N)
        {
            if (bases == null) throw new ArgumentNullException();
            if (bases.Length == 0) throw new ArgumentException();
            if (N < 0) throw new ArgumentOutOfRangeException();

            for (int i = 1; i < bases.Length; i++)
            {
                for (int j = 0; j < i; j++)
                {
                    int gcd = Numbers.GCD(bases[i], bases[j]);

                    if (gcd != 1)
                    {
                        throw new ArgumentException($"Values must be coprime. {bases[i]} and {bases[j]} share a factor of {gcd}.");
                    }
                }
            }

            var s = bases.Select(b => VanDerCorputD(b).GetEnumerator()).ToArray();
            var x = new Double[bases.Length + 1];

            for (int n = 1; n <= N; n++)
            {
                for (int i = 0; i < bases.Length; i++)
                {
                    s[i].MoveNext();
                    x[i] = s[i].Current;
                }

                x[bases.Length] = n / (Double)N;
                yield return x;
            }
        }

        /// <summary>
        /// Hammersley sequence.
        /// </summary>
        public static IEnumerable<Double[]> HammersleyD(int dimension, int N)
        {
            if (dimension < 2) throw new ArgumentOutOfRangeException();
            return HammersleyD(Sequences.Primes().Select(_ => (int)_).Take(dimension - 1).ToArray(), N);
        }

        /// <summary>
        /// Additive recurrence, sₙ = (s₀ + αn) mod 1.
        /// </summary>
        /// <param name="s0">Value from 0 to 1 exclusive.</param>
        /// <param name="α">Value from 0 to 1 exclusive.</param>
	    public static IEnumerable<Single> AdditiveRecurrence(Single s0, Single α)
        {
            if (s0 <= 0 || s0 >= 1) throw new ArgumentOutOfRangeException(nameof(s0));
            if (α <= 0 || α >= 1) throw new ArgumentOutOfRangeException(nameof(α));
            var s = s0;

            while (true)
            {
                yield return s;
                s += α;
                if (s >= 1) s -= 1;
            }
        }

        /// <summary>
        /// Additive recurrence, sₙ = (α + αn) mod 1.
        /// </summary>
        /// <param name="α">Value from 0 to 1 exclusive.</param>
	    public static IEnumerable<Single> AdditiveRecurrence(Single α)
        {
            return AdditiveRecurrence(α, α);
        }

        /// <summary>
        /// Additive recurrence sₙ = (s₀ + αn) mod 1 with random s₀ and algebraic α of degree 2
        /// using specified random number generator.
        /// </summary>
	    public static IEnumerable<Single> AdditiveRecurrenceF(Generator generator)
        {
            if (generator == null) throw new ArgumentNullException();

            return AdditiveRecurrence(generator.Single(), (Single)
                generator.UInt64s()
                    .Select(u => Math.Sqrt(u))
                    .Select(f => f - Math.Floor(f))
                    .First(f => f > 0.3F && f < 0.7F));
        }

        /// <summary>
        /// Additive recurrence sₙ = (s₀ + αn) mod 1 with random s₀ and algebraic α of degree 2
        /// using default random number generator.
        /// </summary>
	    public static IEnumerable<Single> AdditiveRecurrenceF()
        {
            return AdditiveRecurrenceF(new Generator());
        }

        /// <summary>
        /// Van der Corput sequence.
        /// </summary>
        public static IEnumerable<Single> VanDerCorputF(int @base)
        {
            if (@base < 2) throw new ArgumentOutOfRangeException();
            var digits = new int[1];
            long denom = @base;

            while (true)
            {
                int i = 0;
                long num = 0;

                while (true)
                {
                    num = num * @base + ++digits[i];
                    if (digits[i] < @base) break;
                    digits[i] = 0;
                    num -= @base;
                    i++;

                    if (i >= digits.Length)
                    {
                        Array.Resize(ref digits, digits.Length + 1);
                        denom *= @base;
                    }
                }

                while (++i < digits.Length)
                {
                    num = num * @base + digits[i];
                }

                yield return num / (Single)denom;
            }
        }

        /// <summary>
        /// Halton sequence.
        /// </summary>
        public static IEnumerable<Single[]> HaltonF(int[] bases)
        {
            if (bases == null) throw new ArgumentNullException();
            if (bases.Length == 0) throw new ArgumentException();

            for (int i = 1; i < bases.Length; i++)
            {
                for (int j = 0; j < i; j++)
                {
                    int gcd = Numbers.GCD(bases[i], bases[j]);

                    if (gcd != 1)
                    {
                        throw new ArgumentException($"Values must be coprime. {bases[i]} and {bases[j]} share a factor of {gcd}.");
                    }
                }
            }

            var s = bases.Select(b => VanDerCorputF(b).GetEnumerator()).ToArray();
            var x = new Single[bases.Length];

            while (true)
            {
                for (int i = 0; i < bases.Length; i++)
                {
                    s[i].MoveNext();
                    x[i] = s[i].Current;
                }

                yield return x;
            }
        }

        /// <summary>
        /// Halton sequence.
        /// </summary>
        public static IEnumerable<Single[]> HaltonF(int dimension)
        {
            if (dimension < 0) throw new ArgumentOutOfRangeException();
            return HaltonF(Sequences.Primes().Select(_ => (int)_).Take(dimension).ToArray());
        }

        /// <summary>
        /// Hammersley set.
        /// </summary>
        public static IEnumerable<Single[]> HammersleyF(int[] bases, int N)
        {
            if (bases == null) throw new ArgumentNullException();
            if (bases.Length == 0) throw new ArgumentException();
            if (N < 0) throw new ArgumentOutOfRangeException();

            for (int i = 1; i < bases.Length; i++)
            {
                for (int j = 0; j < i; j++)
                {
                    int gcd = Numbers.GCD(bases[i], bases[j]);

                    if (gcd != 1)
                    {
                        throw new ArgumentException($"Values must be coprime. {bases[i]} and {bases[j]} share a factor of {gcd}.");
                    }
                }
            }

            var s = bases.Select(b => VanDerCorputF(b).GetEnumerator()).ToArray();
            var x = new Single[bases.Length + 1];

            for (int n = 1; n <= N; n++)
            {
                for (int i = 0; i < bases.Length; i++)
                {
                    s[i].MoveNext();
                    x[i] = s[i].Current;
                }

                x[bases.Length] = n / (Single)N;
                yield return x;
            }
        }

        /// <summary>
        /// Hammersley sequence.
        /// </summary>
        public static IEnumerable<Single[]> HammersleyF(int dimension, int N)
        {
            if (dimension < 2) throw new ArgumentOutOfRangeException();
            return HammersleyF(Sequences.Primes().Select(_ => (int)_).Take(dimension - 1).ToArray(), N);
        }

        /// <summary>
        /// Additive recurrence, sₙ = (s₀ + αn) mod 1.
        /// </summary>
        /// <param name="s0">Value from 0 to 1 exclusive.</param>
        /// <param name="α">Value from 0 to 1 exclusive.</param>
	    public static IEnumerable<Decimal> AdditiveRecurrence(Decimal s0, Decimal α)
        {
            if (s0 <= 0 || s0 >= 1) throw new ArgumentOutOfRangeException(nameof(s0));
            if (α <= 0 || α >= 1) throw new ArgumentOutOfRangeException(nameof(α));
            var s = s0;

            while (true)
            {
                yield return s;
                s += α;
                if (s >= 1) s -= 1;
            }
        }

        /// <summary>
        /// Additive recurrence, sₙ = (α + αn) mod 1.
        /// </summary>
        /// <param name="α">Value from 0 to 1 exclusive.</param>
	    public static IEnumerable<Decimal> AdditiveRecurrence(Decimal α)
        {
            return AdditiveRecurrence(α, α);
        }

        /// <summary>
        /// Additive recurrence sₙ = (s₀ + αn) mod 1 with random s₀ and algebraic α of degree 2
        /// using specified random number generator.
        /// </summary>
	    public static IEnumerable<Decimal> AdditiveRecurrenceM(Generator generator)
        {
            if (generator == null) throw new ArgumentNullException();

            return AdditiveRecurrence(generator.Decimal(), (Decimal)
                generator.UInt64s()
                    .Select(u => MathM.Sqrt(u))
                    .Select(f => f - MathM.Floor(f))
                    .First(f => f > 0.3M && f < 0.7M));
        }

        /// <summary>
        /// Additive recurrence sₙ = (s₀ + αn) mod 1 with random s₀ and algebraic α of degree 2
        /// using default random number generator.
        /// </summary>
	    public static IEnumerable<Decimal> AdditiveRecurrenceM()
        {
            return AdditiveRecurrenceM(new Generator());
        }

        /// <summary>
        /// Van der Corput sequence.
        /// </summary>
        public static IEnumerable<Decimal> VanDerCorputM(int @base)
        {
            if (@base < 2) throw new ArgumentOutOfRangeException();
            var digits = new int[1];
            long denom = @base;

            while (true)
            {
                int i = 0;
                long num = 0;

                while (true)
                {
                    num = num * @base + ++digits[i];
                    if (digits[i] < @base) break;
                    digits[i] = 0;
                    num -= @base;
                    i++;

                    if (i >= digits.Length)
                    {
                        Array.Resize(ref digits, digits.Length + 1);
                        denom *= @base;
                    }
                }

                while (++i < digits.Length)
                {
                    num = num * @base + digits[i];
                }

                yield return num / (Decimal)denom;
            }
        }

        /// <summary>
        /// Halton sequence.
        /// </summary>
        public static IEnumerable<Decimal[]> HaltonM(int[] bases)
        {
            if (bases == null) throw new ArgumentNullException();
            if (bases.Length == 0) throw new ArgumentException();

            for (int i = 1; i < bases.Length; i++)
            {
                for (int j = 0; j < i; j++)
                {
                    int gcd = Numbers.GCD(bases[i], bases[j]);

                    if (gcd != 1)
                    {
                        throw new ArgumentException($"Values must be coprime. {bases[i]} and {bases[j]} share a factor of {gcd}.");
                    }
                }
            }

            var s = bases.Select(b => VanDerCorputM(b).GetEnumerator()).ToArray();
            var x = new Decimal[bases.Length];

            while (true)
            {
                for (int i = 0; i < bases.Length; i++)
                {
                    s[i].MoveNext();
                    x[i] = s[i].Current;
                }

                yield return x;
            }
        }

        /// <summary>
        /// Halton sequence.
        /// </summary>
        public static IEnumerable<Decimal[]> HaltonM(int dimension)
        {
            if (dimension < 0) throw new ArgumentOutOfRangeException();
            return HaltonM(Sequences.Primes().Select(_ => (int)_).Take(dimension).ToArray());
        }

        /// <summary>
        /// Hammersley set.
        /// </summary>
        public static IEnumerable<Decimal[]> HammersleyM(int[] bases, int N)
        {
            if (bases == null) throw new ArgumentNullException();
            if (bases.Length == 0) throw new ArgumentException();
            if (N < 0) throw new ArgumentOutOfRangeException();

            for (int i = 1; i < bases.Length; i++)
            {
                for (int j = 0; j < i; j++)
                {
                    int gcd = Numbers.GCD(bases[i], bases[j]);

                    if (gcd != 1)
                    {
                        throw new ArgumentException($"Values must be coprime. {bases[i]} and {bases[j]} share a factor of {gcd}.");
                    }
                }
            }

            var s = bases.Select(b => VanDerCorputM(b).GetEnumerator()).ToArray();
            var x = new Decimal[bases.Length + 1];

            for (int n = 1; n <= N; n++)
            {
                for (int i = 0; i < bases.Length; i++)
                {
                    s[i].MoveNext();
                    x[i] = s[i].Current;
                }

                x[bases.Length] = n / (Decimal)N;
                yield return x;
            }
        }

        /// <summary>
        /// Hammersley sequence.
        /// </summary>
        public static IEnumerable<Decimal[]> HammersleyM(int dimension, int N)
        {
            if (dimension < 2) throw new ArgumentOutOfRangeException();
            return HammersleyM(Sequences.Primes().Select(_ => (int)_).Take(dimension - 1).ToArray(), N);
        }

    }
}
