<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>

/*
Generator.cs

<#@ include file="../../License.txt" #>
*/

using Foundations.Types;
using System;
using System.Collections.Generic;

namespace Foundations.RandomNumbers
{
    /// <summary>
    /// Pseudo-random number generator.
    /// </summary>
    public sealed partial class Generator
    {
        /// <summary>
        /// A delegate that creates a <see cref="IRandomSource"/> with a <see cref="IRandomSource.AllocateState"/>
        /// method implementation that returns null. This source is used to generate initial state data
        /// from raw seed data for any <see cref="IRandomSource"/> that returns a non-null value
        /// from <see cref="IRandomSource.AllocateState"/>.
        /// </summary>
        public static Func<IRandomSource> DefaultStateInitializationFactory = delegate
        {
            return new SHA256RandomSource();
        };

        /// <summary>
        /// A delegate that creates a <see cref="IRandomSource"/>. This is the source that
        /// will be used when a <see cref="Generator"/> is created using a constructor that
        /// does not specify a <see cref="IRandomSource"/>.
        /// </summary>
        public static Func<IRandomSource> DefaultSourceFactory = delegate
        {
            return new XorShiftRandomSource();
        };

        /// <summary>
        /// Implicitly cast a <see cref="System.Random"/> to a <see cref="Generator"/>
        /// to enable using System.Random values as arguments to Foundations library
        /// functions that require Generator.
        /// </summary>
        public static implicit operator Generator(System.Random random)
        {
            return new Generator(new SystemRandomSource(random));
        }
        
        private IRandomSource source;
        private ValueUnion value;
     
        /// <summary>
        /// Create a pseudo-random number generator initialized using system entropy
        /// and default random source.
        /// </summary>
        public Generator()
            : this(null, (byte[])null)
        {
        }
     
        /// <summary>
        /// Create a pseudo-random number generator initialized using system entropy
        /// and specified random source.
        /// </summary>
        public Generator(IRandomSource source)
            : this(source, (byte[])null)
        {
        }

        /// <summary>
        /// Create a pseudo-random number generator initialized with provided seed data
        /// and default random source.
        /// </summary>
        public Generator(params byte[] seed)
            : this(null, seed)
        {
        }

        /// <summary>
        /// Create a pseudo-random number generator initialized with provided seed data
        /// and specified random source.
        /// </summary>
        public Generator(IRandomSource source, params byte[] seed)
        {
            if (source == null)
            {
                source = DefaultSourceFactory();
            }

            this.source = source;
            var state = source.AllocateState();

            if (seed == null)
            {
                if (state == null)
                {
                    throw new ArgumentException("The specified IRandomSource cannot be used without a seed.", nameof(source));
                }

                seed = new byte[Buffer.ByteLength(state)];

                using (var rng = System.Security.Cryptography.RandomNumberGenerator.Create())
                {
                    rng.GetBytes(seed);
                }
            }

            if (state == null)
            {
                state = seed;
            }
            else
            {
                var stateSource = DefaultStateInitializationFactory();
                CreateState(stateSource, seed, state);
                var dispose = stateSource as IDisposable;
                if (dispose != null) dispose.Dispose();
            }

            source.Initialize(state);
        }

        private Generator(IRandomSource source, bool throwIfNonClonable)
        {
            this.source = source.Clone();

            if (this.source ==  null && throwIfNonClonable)
                throw new ArgumentException("Source generator is using a source that cannot be cloned.");
        }

        /// <summary>
        /// Create a pseudo-random number generator with the same state as an existing one.
        /// </summary>
        public Generator(Generator generator)
            : this(generator.source, true)
        {
        }

        /// <summary>
        /// Gets a copy of this <see cref="Generator"/> with the same state.
        /// </summary>
        public Generator Clone()
        {
            var source = this.source.Clone();
            if (source == null) return null;
            return new Generator(source, false);
        }

        /// <summary>
        /// Gets a synchronized ("thread-safe") copy of this <see cref="Generator"/>.
        /// </summary>
        public Generator Synchronized()
        {
            return new Generator(new SynchronizedRandomSource(source));
        }
<#
    Seed("ulong");
    Seed("long");
    Seed("uint");
    Seed("int");
    Seed("ushort");
    Seed("short");
    Seed("sbyte");
    Seed("char");
    Seed("float");
    Seed("double");
    Seed("bool");
#>

        /// <summary>
        /// Create a pseudo-random number generator seeded with string contents.
        /// </summary>
        public Generator(IRandomSource source, string seed)
            : this(source, seed.ToCharArray().GetBytes())
        {
        }

        /// <summary>
        /// Create a pseudo-random number generator seeded with string contents.
        /// </summary>
        public Generator(string seed)
            : this(null, seed.ToCharArray().GetBytes())
        {
        }
<#
    Next("UInt64", 1);
    Next("Int64", 1);
    Next("UInt32", 2);
    Next("Int32", 2);
    Next("UInt16", 4);
    Next("Int16", 4);
    Next("Byte", 8);
    Next("SByte", 8);
    Next("Double", 1);
    Next("Single", 2);
    Next("Decimal", 1);
#>
        /// <summary>
        /// Gets a random <see cref="System.Boolean"/> value.
        /// </summary>
        public Boolean Boolean()
        {
            Next();
            return (value.UInt64_0 & 1UL) != 0;
        }

        /// <summary>
        /// Fill a provided array with random <see cref="System.Boolean"/> values.
        /// </summary>
        public void Fill(Boolean[] array)
        {
            if (array == null) 
                throw new ArgumentNullException(nameof(array));

            Fill(array, 0, array.Length);
        }

        /// <summary>
        /// Fill a specified portion of a provided array with random <see cref="System.Boolean"/> values.
        /// </summary>
        unsafe public void Fill(Boolean[] array, int offset, int count)
        {
            if (array == null) 
                throw new ArgumentNullException(nameof(array));

            if (offset < 0 || offset > array.Length) 
                throw new ArgumentOutOfRangeException(nameof(offset));

            if (count == 0)
                return;

            if (count < 0 || count > array.Length - offset) 
                throw new ArgumentOutOfRangeException(nameof(count));

            fixed (Boolean* ptr = &array[offset])
            {
                var p = ptr;

                while (count >= 64)
                {
                    Next();
<# for (int i = 0; i < 64; i++) { #>
                    *p++ = (value.UInt32_<#= i / 32 #> & 0x<#= (1u << (i % 32)).ToString("X") #>) != 0;
<# } #>
                    count -= 64;
                }

                if (count == 0)
                    return;

                Next();

                switch (count)
                {
<# for (int i = 63; i > 0; i--) { #>
                    case <#= i #>:
                        *p++ = (value.UInt32_<#= (63-i)/32 #> & 0x<#= (1u << ((63 - i) % 32)).ToString("X") #>) != 0;
<#   if (i > 1) { #>
                        goto case <#= i - 1 #>;
<#   } else { #>
                        break;
<#
     }
   } 
#>
                }
            }
        }

        /// <summary>
        /// Mixes random <see cref="System.Boolean"/> values into an array using exclusive-OR operation.
        /// </summary>
        public void XorFill(Boolean[] array)
        {
            if (array == null) 
                throw new ArgumentNullException(nameof(array));

            XorFill(array, 0, array.Length);
        }

        /// <summary>
        /// Mixes random <see cref="System.Boolean"/> values into an array using exclusive-OR operation.
        /// </summary>
        unsafe public void XorFill(Boolean[] array, int offset, int count)
        {
            if (array == null) 
                throw new ArgumentNullException(nameof(array));

            if (offset < 0 || offset > array.Length) 
                throw new ArgumentOutOfRangeException(nameof(offset));

            if (count == 0)
                return;

            if (count < 0 || count > array.Length - offset) 
                throw new ArgumentOutOfRangeException(nameof(count));

            fixed (Boolean* ptr = &array[offset])
            {
                var p = ptr;

                while (count >= 64)
                {
                    Next();
<# for (int i = 0; i < 64; i++) { #>
                    *p++ ^= (value.UInt32_<#= i/32 #> & 0x<#= (1u << (i % 32)).ToString("X") #>) != 0;
<# } #>
                    count -= 64;
                }

                if (count == 0)
                    return;

                Next();

                switch (count)
                {
<# for (int i = 63; i > 0; i--) { #>
                    case <#= i #>:
                        *p++ ^= (value.UInt32_<#= (63-i)/32 #> & 0x<#= (1u << ((63 - i)%32)).ToString("X") #>) != 0;
<#   if (i > 1) { #>
                        goto case <#= i - 1 #>;
<#   } else { #>
                        break;
<#
     }
   } 
#>
                }
            }
        }

        /// <summary>
        /// Gets a sequence of Boolean values.
        /// </summary>
        public IEnumerable<Boolean> Booleans()
        {
            while (true)
            {
                Next();
<# for (int i = 0; i < 64; i++) { #>
                yield return (value.UInt32_<#= i/32 #> & 0x<#= (1u << (i % 32)).ToString("X") #>) != 0;
<# } #>
            }
        }

        /// <summary>
        /// Allocate an array of <see cref="System.Boolean"/>s and fill it with random values.
        /// </summary>
        public Boolean[] CreateBooleans(int count)
        {
            if (count < 0)
                throw new ArgumentOutOfRangeException(nameof(count));

            var data = new Boolean[count];
            Fill(data);
            return data;
        }

        private void Next()
        {
            source.Next(ref value);
        }

        /// <summary>
        /// Gets a random <see cref="ValueUnion"/> value.
        /// </summary>
        public ValueUnion ValueUnion()
        {
            Next();
            return value;
        }

        /// <summary>
        /// Fill a provided array with random <see cref="ValueUnion"/> values.
        /// </summary>
        public void Fill(ValueUnion[] array)
        {
            if (array == null) 
                throw new ArgumentNullException(nameof(array));

            Fill(array, 0, array.Length);
        }

        /// <summary>
        /// Fill a specified portion of a provided array with random <see cref="ValueUnion"/> values.
        /// </summary>
        unsafe public void Fill(ValueUnion[] array, int offset, int count)
        {
            if (array == null) 
                throw new ArgumentNullException(nameof(array));

            if (offset < 0 || offset > array.Length) 
                throw new ArgumentOutOfRangeException(nameof(offset));

            if (count == 0)
                return;

            if (count < 0 || count > array.Length - offset) 
                throw new ArgumentOutOfRangeException(nameof(count));

            fixed (ValueUnion* ptr = &array[offset])
            {
                var p = (ValueUnion*)ptr;

                while (count >= 1)
                {
                    source.Next(ref *p++);
                    count -= 1;
                }
            }
        }

        /// <summary>
        /// Gets a sequence of ValueUnion values.
        /// </summary>
        public IEnumerable<ValueUnion> ValueUnions()
        {
            while(true)
            {
                yield return ValueUnion();
            }
        }

        /// <summary>
        /// Allocate an array of <see cref="ValueUnion"/>s and fill it with random values.
        /// </summary>
        public ValueUnion[] CreateValueUnions(int count)
        {
            if (count < 0)
                throw new ArgumentOutOfRangeException(nameof(count));

            var data = new ValueUnion[count];
            Fill(data);
            return data;
        }

        private static void CreateState(IRandomSource source, byte[] seed, ValueUnion[] state)
        {
            if (source == null)
                throw new ArgumentNullException(nameof(source));

            if (seed == null)
                throw new ArgumentNullException(nameof(seed));

            if (state == null)
                throw new ArgumentNullException(nameof(state));

            var rand = new Generator(source, seed);
            rand.Fill(state);
        }

        private static void CreateState(IRandomSource source, byte[] seed, Array state)
        {
            switch (Type.GetTypeCode(state.GetType().GetElementType()))
            {
<#
    foreach (string T in types)
    {
#>
                case TypeCode.<#= T #>:
                    CreateState(source, seed, state as <#= T #>[]);
                    return;

<#
    }
#>
                case TypeCode.Object:
                    if (state is ValueUnion[])
                    {
                        CreateState(source, seed, state as ValueUnion[]);
                        return;
                    }
                    break;
            }

            throw new NotSupportedException("Unsupported array type.");
        }
    }
}
<#+
void Seed(string T)
{
#>

        /// <summary>
        /// Create a pseudo-random number generator initialized with provided values.
        /// </summary>
        public Generator(IRandomSource source, params <#= T #>[] seed)
            : this(source, seed.GetBytes())
        {
        }

        /// <summary>
        /// Create a pseudo-random number generator initialized with provided values.
        /// </summary>
        public Generator(params <#= T #>[] seed)
            : this(null, seed.GetBytes())
        {
        }
<#+
}

List<string> types = new List<string>();

void Next(string T, int m)
{
    types.Add(T);
#>

        /// <summary>
        /// Gets a random <see cref="System.<#= T #>"/> value.
        /// </summary>
        public <#= T #> <#= T #>()
        {
<#+
    if (T == "Single" || T == "Double")
    {
#>
            Next();
            return (<#= T #>)(BitConverter.Int64BitsToDouble((value.Int64_0 & 0x000FFFFFFFFFFFFF) | 0x3FF0000000000000) - 1.0);
<#+
    }
    else if (T == "Decimal")
    {
#>
            while(true)
            {
                ulong u = UInt64();
                uint i = UInt32();
                var d = new decimal((int)(i >> 2), (int)u, (int)(u >> 32), false, 28);
                if (d < 1m) return d;
            }
<#+
    }
    else
    {
#>
            Next();
            return value.<#= T #>_0;
<#+
    }
#>
        }
<#+
    if (T[0] == 'I' || T == "SByte")
    {
#>

        /// <summary>
        /// Gets a random non-negative <see cref="System.<#= T #>"/> value.
        /// </summary>
        public <#= T #> <#= T #>NonNegative()
        {
            return (<#= T #>)(<#= T #>() & 0x7<#= new string('F', 16 / m - 1) #>);
        }
<#+
    }

    string UT = null, U = null;

    if (T != "Single" && T != "Double" && T != "Decimal")
    {
        UT = T.EndsWith("Byte") ? "Byte" :
             T[0] == 'U' || T == "Boolean" ? T :
             "U" + T;

        U = "(" + UT + ")";
#>

        private <#= UT #> GetRangeMask(<#= T #> range)
        {
            var mask = <#= U #>(range - 1);
<#+
        int bits = 64 / m;
        int shift = 1;

        while (shift < bits)
        {
#>
            mask |= <#= U #>(mask >> <#= shift #>);
<#+
            shift *= 2;
        }
#>
            return mask;
        }
<#+
    }
#>

        /// <summary>
        /// Gets a random <see cref="System.<#= T #>"/> value.
        /// </summary>
        /// <param ref="range">The range of values to return.</param>
        /// <returns>Returns a value between 0 (inclusive) and range (exclusive).</returns>
        public <#= T #> <#= T #>(<#= T #> range)
        {
            if (range <= 0)
                throw new ArgumentOutOfRangeException(nameof(range));

<#+
    if (T == "Single" || T == "Double" || T == "Decimal")
    {
#>
            return range * <#= T #>();
<#+
    }
    else
    {
#>
            <#= UT #> mask = GetRangeMask(range);
            <#= T #> sample;

            do
            {
                sample = (<#= T #>)(<#= T #>() & (<#= T #>)mask);
            }
            while (sample >= range);

            return sample;
<#+
    }
#>
        }

        /// <summary>
        /// Gets a random <see cref="System.<#= T #>"/> value.
        /// </summary>
        /// <param ref="minimum">The minimum value to return.</param>
        /// <param ref="range">The range of values to return.</param>
        /// <returns>Returns a value between minimum (inclusive) and minimum+range (exclusive).</returns>
        public <#= T #> <#= T #>(<#= T #> minimum, <#= T #> range)
        {
            if (range <= 0)
                throw new ArgumentOutOfRangeException(nameof(range));

            if (System.<#= T #>.MaxValue - range < minimum)
                throw new ArgumentOutOfRangeException(nameof(range));

            return (<#= T #>)(minimum + <#= T #>(range));
        }

        /// <summary>
        /// Fill a provided array with random <see cref="System.<#= T #>"/> values.
        /// </summary>
        public void Fill(<#= T #>[] array)
        {
            if (array == null) 
                throw new ArgumentNullException(nameof(array));

            Fill(array, 0, array.Length);
        }

        /// <summary>
        /// Fill a provided array with random <see cref="System.<#= T #>"/> values.
        /// </summary>
        public void Fill(<#= T #> range, <#= T #>[] array)
        {
            if (array == null) 
                throw new ArgumentNullException(nameof(array));

            Fill(0, range, array, 0, array.Length);
        }

        /// <summary>
        /// Fill a provided array with random <see cref="System.<#= T #>"/> values.
        /// </summary>
        public void Fill(<#= T #> minimum, <#= T #> range, <#= T #>[] array)
        {
            if (array == null) 
                throw new ArgumentNullException(nameof(array));

            Fill(minimum, range, array, 0, array.Length);
        }

        /// <summary>
        /// Fill a specified portion of a provided array with random <see cref="System.<#= T #>"/> values.
        /// </summary>
        unsafe public void Fill(<#= T #>[] array, int offset, int count)
        {
            if (array == null) 
                throw new ArgumentNullException(nameof(array));

            if (offset < 0 || offset > array.Length) 
                throw new ArgumentOutOfRangeException(nameof(offset));

            if (count == 0)
                return;

            if (count < 0 || count > array.Length - offset) 
                throw new ArgumentOutOfRangeException(nameof(count));

<#+
    if (T == "Decimal")
    {
#>
            while (count-- > 0)
            {
                array[offset++] = Decimal();
            }
<#+
    }
    else
    {
#>
            fixed (<#= T #>* ptr = &array[offset])
            {
                var p = (ulong*)ptr;
<#+
        if (T == "Single" || T == "Double")
        {
#>
                var f = ptr;
<#+
        }
#>

                while (count >= <#= m #>)
                {
                    Next();
                    *p++ = <#= FixFP(T) #>;
<#+
        if (T == "Single")
        {
#>
                    *f++ -= 1f;
                    *f++ -= 1f;
<#+
        }
        else if (T == "Double")
        {
#>
                    *f++ -= 1d;
<#+
        }
#>
                    count -= <#= m #>;
                }
<#+
        if (m == 2)
        {
#>

                if (count == 0)
                    return;

                Next();
                ulong sample = <#= FixFP(T) #>;
                var p1 = (<#= T #>*)p;
                var p2 = (<#= T #>*)&sample;
                *p1 = *p2<#= T == "Single" ? " - 1f" : "" #>;
<#+
        }
        else if (m > 2)
        {
#>

                if (count == 0)
                    return;

                Next();
                ulong sample = <#= FixFP(T) #>;
                var p1 = (<#= T #>*)p;
                var p2 = (<#= T #>*)&sample;

                while (count-- > 0)
                {
                    *p1++ = *p2++;
                }
<#+
        }
#>
            }
<#+
    }
#>
        }

        /// <summary>
        /// Fill a specified portion of a provided array with random <see cref="System.<#= T #>"/> values.
        /// </summary>
        public void Fill(<#= T #> minimum, <#= T #> range, <#= T #>[] array, int offset, int count)
        {
            if (range <= 0)
                throw new ArgumentOutOfRangeException(nameof(range));

            if (System.<#= T #>.MaxValue - range < minimum)
                throw new ArgumentOutOfRangeException(nameof(range));

            if (array == null) 
                throw new ArgumentNullException(nameof(array));

            if (offset < 0 || offset >= array.Length) 
                throw new ArgumentOutOfRangeException(nameof(offset));

            if (count < 0 || count > array.Length - offset) 
                throw new ArgumentOutOfRangeException(nameof(count));
<#+
    if (UT != null)
    {
#>

            ulong mask = GetRangeMask(range);
<#+
        for (int i = m / 2; i > 0; i /= 2)
        {
#>
            mask |= mask << <#= 32 / i #>;
<#+
        }
    }

    if (T == "Single")
    {
#>

            while (count >= 2)
            {
                Next();
                value.UInt64_0 = <#= FixFP(T) #>;
                array[offset++] = minimum + (value.Single_0 - 1f) * range;
                array[offset++] = minimum + (value.Single_1 - 1f) * range;
                count -= 2;
            }

            if (count >= 1)
            {
                Next();
                value.UInt64_0 = <#= FixFP(T) #>;
                array[offset++] = minimum + (value.Single_0 - 1f) * range;
            }
<#+
    }
    else if (m > 1)
    {
#>

            while (count > 0)
            {
                Next();
                value.UInt64_0 &= mask;
<#+
        for (int i = 0; i < m; i++)
        {
#>

                if (value.<#= T #>_<#= i #> < range) 
                { 
                    array[offset++] = (<#= T #>)(minimum + value.<#= T #>_<#= i #>); 
                    if (--count == 0) break; 
                }
<#+
        }
#>
            }
<#+
    }
    else
    {
#>

            while (count-- > 0)
            {
                array[offset++] = <#= T #>(minimum, range);
            }
<#+
    }
#>
        }
<#+
    if (T != "Single" && T != "Double" && T != "Decimal")
    {
#>

        /// <summary>
        /// Mixes random <see cref="System.<#= T #>"/> values into an array using exclusive-OR operation.
        /// </summary>
        public void XorFill(<#= T #>[] array)
        {
            if (array == null) 
                throw new ArgumentNullException(nameof(array));

            XorFill(array, 0, array.Length);
        }

        /// <summary>
        /// Mixes random <see cref="System.<#= T #>"/> values into an array using exclusive-OR operation.
        /// </summary>
        /// <param name="range">Maximum value, exclusive. Must be a power of 2.</param>
        /// <param name="array">The array into which the random values will be mixed.</param>
        public void XorFill(<#= T #> range, <#= T #>[] array)
        {
            if ((range & (range - 1)) != 0)
                throw new ArgumentException("Parameter must be a power of 2.", nameof(range));

            if (array == null) 
                throw new ArgumentNullException(nameof(array));

            XorFill(range, array, 0, array.Length);
        }

        /// <summary>
        /// Mixes random <see cref="System.<#= T #>"/> values into an array using exclusive-OR operation.
        /// </summary>
        unsafe public void XorFill(<#= T #>[] array, int offset, int count)
        {
            if (array == null) 
                throw new ArgumentNullException(nameof(array));

            if (offset < 0 || offset > array.Length) 
                throw new ArgumentOutOfRangeException(nameof(offset));

            if (count == 0)
                return;

            if (count < 0 || count > array.Length - offset) 
                throw new ArgumentOutOfRangeException(nameof(count));

            fixed (<#= T #>* ptr = &array[offset])
            {
                var p = (ulong*)ptr;

                while (count >= <#= m #>)
                {
                    Next();
                    *p++ ^= value.UInt64_0;
                    count -= <#= m #>;
                }
<#+
        if (m == 2)
        {
#>

                if (count == 0)
                    return;

                ulong sample = UInt64();
                var p1 = (<#= T #>*)p;
                var p2 = (<#= T #>*)&sample;
                *p1 ^= *p2;
<#+
        }
        else if (m > 2)
        {
#>

                if (count == 0)
                    return;

                ulong sample = UInt64();
                var p1 = (<#= T #>*)p;
                var p2 = (<#= T #>*)&sample;

                while (count-- > 0)
                {
                    *p1++ ^= *p2++;
                }
<#+
        }
#>
            }
        }

        /// <summary>
        /// Mixes random <see cref="System.<#= T #>"/> values into part of an array using exclusive-OR operation.
        /// </summary>
        /// <param name="range">Maximum value, exclusive. Must be a power of 2.</param>
        /// <param name="array">The array into which the random values will be mixed.</param>
        /// <param name="offset">The index of the first element in the array to be affected.</param>
        /// <param name="count">The number of elements in the array to be affected.</param>
        unsafe public void XorFill(<#= T #> range, <#= T #>[] array, int offset, int count)
        {
            if ((range & (range - 1)) != 0)
                throw new ArgumentException("Parameter must be a power of 2.", nameof(range));

            if (array == null) 
                throw new ArgumentNullException(nameof(array));

            if (offset < 0 || offset > array.Length) 
                throw new ArgumentOutOfRangeException(nameof(offset));

            if (count == 0)
                return;

            if (count < 0 || count > array.Length - offset) 
                throw new ArgumentOutOfRangeException(nameof(count));

            ulong mask = GetRangeMask(range);
<#+
        for (int i = m / 2; i > 0; i /= 2)
        {
#>
            mask |= mask << <#= 32 / i #>;
<#+
        }
#>

            fixed (<#= T #>* ptr = &array[offset])
            {
                var p = (ulong*)ptr;

                while (count >= <#= m #>)
                {
                    Next();
                    *p++ ^= value.UInt64_0 & mask;
                    count -= <#= m #>;
                }
<#+
        if (m == 2)
        {
#>

                if (count == 0)
                    return;

                ulong sample = UInt64() & mask;
                var p1 = (<#= T #>*)p;
                var p2 = (<#= T #>*)&sample;
                *p1 ^= *p2;
<#+
        }
        else if (m > 2)
        {
#>

                if (count == 0)
                    return;

                ulong sample = UInt64() & mask;
                var p1 = (<#= T #>*)p;
                var p2 = (<#= T #>*)&sample;

                while (count-- > 0)
                {
                    *p1++ ^= *p2++;
                }
<#+
        }
#>
            }
        }
<#+
    }
#>

        /// <summary>
        /// Adds random <see cref="System.<#= T #>"/> values to values in an array.
        /// </summary>
        public void AddFill(<#= T #>[] array)
        {
            if (array == null) 
                throw new ArgumentNullException(nameof(array));

            AddFill(array, 0, array.Length);
        }

        /// <summary>
        /// Adds random <see cref="System.<#= T #>"/> values in [0, range) to values in an array.
        /// </summary>
        public void AddFill(<#= T #> range, <#= T #>[] array)
        {
            if (array == null) 
                throw new ArgumentNullException(nameof(array));

            AddFill(0, range, array, 0, array.Length);
        }

        /// <summary>
        /// Adds random <see cref="System.<#= T #>"/> values in [minimum, minimum + range) to values in an array.
        /// </summary>
        public void AddFill(<#= T #> minimum, <#= T #> range, <#= T #>[] array)
        {
            if (array == null) 
                throw new ArgumentNullException(nameof(array));

            AddFill(minimum, range, array, 0, array.Length);
        }

        /// <summary>
        /// Adds random <see cref="System.<#= T #>"/> values to part of an array.
        /// </summary>
        public void AddFill(<#= T #>[] array, int offset, int count)
        {
            if (array == null) 
                throw new ArgumentNullException(nameof(array));

            if (offset < 0 || offset >= array.Length) 
                throw new ArgumentOutOfRangeException(nameof(offset));

            if (count < 0 || count > array.Length - offset) 
                throw new ArgumentOutOfRangeException(nameof(count));
<#+
    if (T == "Single")
    {
#>

            while (count >= 2)
            {
                Next();
                value.UInt64_0 = <#= FixFP(T) #>;
				var sample = value.Single_0 - 1f;
                array[offset++] += sample;
				sample = value.Single_1 - 1f;
                array[offset++] += sample;
                count -= 2;
            }

            if (count >= 1)
            {
                Next();
                value.UInt64_0 = <#= FixFP(T) #>;
				var sample = value.Single_0 - 1f;
                array[offset] += sample;
            }
<#+
    }
    else if (m > 1)
    {
#>

            while (count >= <#= m #>)
            {
                Next();
<#+
        for (int i = 0; i < m; i++)
        {
#>
                array[offset++] += value.<#= T #>_<#= i #>;
<#+
        }
#>
                count -= <#= m #>;
            }

            if (count == 0)
                return;

            Next();
<#+
        for (int i = 0; i < m - 1; i++)
        {
#>

            array[offset++] += value.<#= T #>_<#= i #>; 
            if (--count == 0) return;
<#+
        }
    }
    else
    {
#>

            while (count-- > 0)
            {
                array[offset++] += <#= T #>();
            }
<#+
    }
#>
        }

        /// <summary>
        /// Adds random <see cref="System.<#= T #>"/> values in [minimum, minimum + range) to part of an array.
        /// </summary>
        public void AddFill(<#= T #> minimum, <#= T #> range, <#= T #>[] array, int offset, int count)
        {
            if (range <= 0)
                throw new ArgumentOutOfRangeException(nameof(range));

            if (System.<#= T #>.MaxValue - range < minimum)
                throw new ArgumentOutOfRangeException(nameof(range));

            if (array == null) 
                throw new ArgumentNullException(nameof(array));

            if (offset < 0 || offset >= array.Length) 
                throw new ArgumentOutOfRangeException(nameof(offset));

            if (count < 0 || count > array.Length - offset) 
                throw new ArgumentOutOfRangeException(nameof(count));
<#+
    if (UT != null && m > 1)
    {
#>

            ulong mask = GetRangeMask(range);
<#+
        for (int i = m / 2; i > 0; i /= 2)
        {
#>
            mask |= mask << <#= 32 / i #>;
<#+
        }
    }

    if (T == "Single")
    {
#>

            while (count >= 2)
            {
                Next();
                value.UInt64_0 = <#= FixFP(T) #>;
				var sample = minimum + (value.Single_0 - 1f) * range;
                array[offset++] += sample;
				sample = minimum + (value.Single_1 - 1f) * range;
                array[offset++] += sample;
                count -= 2;
            }

            if (count >= 1)
            {
                Next();
                value.UInt64_0 = <#= FixFP(T) #>;
				var sample = minimum + (value.Single_0 - 1f) * range;
                array[offset] += sample;
            }
<#+
    }
    else if (m > 1)
    {
#>

            while (count > 0)
            {
                Next();
                value.UInt64_0 &= mask;
<#+
        for (int i = 0; i < m; i++)
        {
#>

                if (value.<#= T #>_<#= i #> < range) 
                { 
                    array[offset++] += (<#= T #>)(minimum + value.<#= T #>_<#= i #>); 
                    if (--count == 0) break; 
                }
<#+
        }
#>
            }
<#+
    }
    else
    {
#>

            while (count-- > 0)
            {
                array[offset++] += <#= T #>(minimum, range);
            }
<#+
    }
#>
        }

        /// <summary>
        /// Adds random <see cref="System.<#= T #>"/> values in [0, range) to part of an array.
        /// </summary>
        public void AddFill(<#= T #> range, <#= T #>[] array, int offset, int count)
        {
            AddFill(0, range, array, offset, count);
        }

        /// <summary>
        /// Gets a sequence of <#= T #> values.
        /// </summary>
        public IEnumerable<<#= T #>> <#= T #>s()
        {
            while (true)
            {
<#+ 
    if (m == 1)
    {
#>
                yield return <#= T #>();
<#+
    }
    else if (T == "Single")
    {
#>
                Next();
                value.UInt64_0 = <#= FixFP(T) #>;
                yield return value.Single_0 - 1f;
                yield return value.Single_1 - 1f;
<#+
    }
    else
    {
#>
                Next();
<#+
        for (int i = 0; i < m; i++) 
        { 
#>
                yield return value.<#= T #>_<#= i #>;
<#+
        }
    }
#>
            }
        }

        /// <summary>
        /// Gets a sequence of <#= T #> values in [0, range).
        /// </summary>
        public IEnumerable<<#= T #>> <#= T #>s(<#= T #> range)
        {
            return <#= T #>s(0, range);
        }

        /// <summary>
        /// Gets a sequence of <#= T #> values in [minimum, minimum + range).
        /// </summary>
        public IEnumerable<<#= T #>> <#= T #>s(<#= T #> minimum, <#= T #> range)
        {
            if (range <= 0)
                throw new ArgumentOutOfRangeException(nameof(range));

            if (System.<#= T #>.MaxValue - range < minimum)
                throw new ArgumentOutOfRangeException(nameof(range));
<#+
    if (U != null)
    {
#>

            ulong mask = GetRangeMask(range);
<#+
        for (int i = m; i > 1; i /= 2)
        {
#>
            mask |= mask << <#= 64 / i #>;
<#+
        }
    }
#>

            while(true)
            {
<#+
    if (T == "Single")
    {
#>
                Next();
                value.UInt64_0 = <#= FixFP(T) #>;
                yield return minimum + (value.Single_0 - 1f) * range;
                yield return minimum + (value.Single_1 - 1f) * range;
<#+
    }
    else if (T == "Double" || T == "Decimal")
    {
#>
                yield return <#= T #>(minimum, range);
<#+
    }
    else
    {
#>
                Next();
                value.UInt64_0 &= mask;
<#+
        for (int i = 0; i < m; i++)
        {
#>
                if (value.<#= T #>_<#= i #> < range) yield return (<#= T #>)(minimum + value.<#= T #>_<#= i #>);
<#+
        }
    }
#>
            }
        }

        /// <summary>
        /// Allocate an array of <see cref="System.<#= T #>"/>s and fill it with random values.
        /// </summary>
        public <#= T #>[] Create<#= T #>s(int count)
        {
            if (count < 0)
                throw new ArgumentOutOfRangeException(nameof(count));

            var data = new <#= T #>[count];
            Fill(data);
            return data;
        }

        /// <summary>
        /// Allocate an array of <see cref="System.<#= T #>"/>s and fill it with random values in [0, range).
        /// </summary>
        public <#= T #>[] Create<#= T #>s(int count, <#= T #> range)
        {
            if (count < 0)
                throw new ArgumentOutOfRangeException(nameof(count));

            var data = new <#= T #>[count];
            Fill(range, data);
            return data;
        }

        /// <summary>
        /// Allocate an array of <see cref="System.<#= T #>"/>s and fill it with random values in [minimum, minimum + range).
        /// </summary>
        public <#= T #>[] Create<#= T #>s(int count, <#= T #> minimum, <#= T #> range)
        {
            if (count < 0)
                throw new ArgumentOutOfRangeException(nameof(count));

            var data = new <#= T #>[count];
            Fill(minimum, range, data);
            return data;
        }
<#+
    if (T[0] == 'I' || T == "SByte")
    {
#>

        /// <summary>
        /// Gets a sequence of non-negative <#= T #> values.
        /// </summary>
        public IEnumerable<<#= T #>> <#= T #>sNonNegative()
        {
            while(true)
            {
                yield return <#= T #>NonNegative();
            }
        }

        /// <summary>
        /// Fill a provided array with non-negative random <see cref="System.<#= T #>"/> values.
        /// </summary>
        public void FillNonNegative(<#= T #>[] array)
        {
            if (array == null) 
                throw new ArgumentNullException(nameof(array));

            FillNonNegative(array, 0, array.Length);
        }

        /// <summary>
        /// Fill a specified portion of a provided array with non-negative random <see cref="System.<#= T #>"/> values.
        /// </summary>
        public void FillNonNegative(<#= T #>[] array, int offset, int count)
        {
            Fill(array, offset, count);

            while (count-- > 0)
            {
                array[offset++] &= 0x7<#= new string('F', 16 / m - 1) #>;
            }
        }
<#+
    }
#>

        private static void CreateState(IRandomSource source, byte[] seed, <#= T #>[] state)
        {
            if (source == null)
                throw new ArgumentNullException(nameof(source));

            if (seed == null)
                throw new ArgumentNullException(nameof(seed));

            if (state == null)
                throw new ArgumentNullException(nameof(state));

            var rand = new Generator(source, seed);
            rand.Fill(state);
        }
<#+
}

string FixFP(string T)
{
    if (T == "Double")
    {
        return "(value.UInt64_0 & 0x000FFFFFFFFFFFFF) | 0x3FF0000000000000";
    }
    
    if (T == "Single")
    {
        return "(value.UInt64_0 & 0x007FFFFF007FFFFF) | 0x3F8000003F800000";
    }

    return "value.UInt64_0";
}
#>
