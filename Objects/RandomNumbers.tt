<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>

/*
RandomNumbers.cs

<#@ include file="../License.txt" #>
*/

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace Foundations.Objects
{
    /// <summary>
    /// Pseudo-random number generator.
    /// </summary>
    public sealed partial class RandomNumbers
    {
        private static byte[] MakeBytes<T>(T[] seed)
        {
            if (seed == null)
                throw new ArgumentNullException(nameof(seed));

            int n = Buffer.ByteLength(seed);
            var bytes = new byte[n];
            Buffer.BlockCopy(seed, 0, bytes, 0, n);
            return bytes;
        }
     
        /// <summary>
        /// Create a pseudo-random number generator initialized using the current value of the high-precision timer.
        /// </summary>
        public RandomNumbers()
            : this(new[] { Stopwatch.GetTimestamp() })
        {
        }

        /// <summary>
        /// Create a pseudo-random number generator initialized with provided values.
        /// </summary>
        public RandomNumbers(params byte[] seed)
        {
            if (seed == null)
                throw new ArgumentNullException(nameof(seed));

            state = new ulong[16];

            using (var sha = System.Security.Cryptography.SHA256.Create())
            {

                for (int i = 0; i < 4; i++)
                {
                    seed = sha.ComputeHash(seed);
                    Buffer.BlockCopy(seed, 0, state, 32 * i, 32);
                }
            }
        }
<#
    Seed("ulong");
    Seed("long");
    Seed("uint");
    Seed("int");
    Seed("ushort");
    Seed("short");
    Seed("sbyte");
    Seed("char");
    Seed("float");
    Seed("double");
#>

        [StructLayout(LayoutKind.Explicit)]
        private struct Sample
        {
            [FieldOffset(0)]
            public ulong UInt64_0;

            [FieldOffset(0)]
            public long Int64_0;

            [FieldOffset(0)]
            public uint UInt32_0;

            [FieldOffset(4)]
            public uint UInt32_1;

            [FieldOffset(0)]
            public int Int32_0;

            [FieldOffset(4)]
            public int Int32_1;

            [FieldOffset(0)]
            public ushort UInt16_0;

            [FieldOffset(2)]
            public ushort UInt16_1;

            [FieldOffset(4)]
            public ushort UInt16_2;

            [FieldOffset(6)]
            public ushort UInt16_3;

            [FieldOffset(0)]
            public short Int16_0;

            [FieldOffset(2)]
            public short Int16_1;

            [FieldOffset(4)]
            public short Int16_2;

            [FieldOffset(6)]
            public short Int16_3;

            [FieldOffset(0)]
            public byte Byte_0;

            [FieldOffset(1)]
            public byte Byte_1;

            [FieldOffset(2)]
            public byte Byte_2;

            [FieldOffset(3)]
            public byte Byte_3;

            [FieldOffset(4)]
            public byte Byte_4;

            [FieldOffset(5)]
            public byte Byte_5;

            [FieldOffset(6)]
            public byte Byte_6;

            [FieldOffset(7)]
            public byte Byte_7;

            [FieldOffset(0)]
            public sbyte SByte_0;

            [FieldOffset(1)]
            public sbyte SByte_1;

            [FieldOffset(2)]
            public sbyte SByte_2;

            [FieldOffset(3)]
            public sbyte SByte_3;

            [FieldOffset(4)]
            public sbyte SByte_4;

            [FieldOffset(5)]
            public sbyte SByte_5;

            [FieldOffset(6)]
            public sbyte SByte_6;

            [FieldOffset(7)]
            public sbyte SByte_7;

            [FieldOffset(0)]
            public double Double_0;

            [FieldOffset(0)]
            public float Single_0;

            [FieldOffset(4)]
            public float Single_1;
        }

        private ulong[] state;
        private int index;

#pragma warning disable 0169
        private Sample sample;
#pragma warning restore 0169

        /// <summary>
        /// Get the next value in the pseudo-random sequence as a <see cref="UInt64"/>.
        /// </summary>
        private ulong Mix()
        {
            ulong prev = state[index];
            index = (index + 1) & 0xF;
            var next = state[index];
            next ^= next << 31;
            return sample.UInt64_0 = (state[index] = next ^ prev ^ (next >> 11) ^ (prev >> 30)) * 1181783497276652981UL;
        }
<#
    Next("UInt64", 1);
    Next("Int64", 1);
    Next("UInt32", 2);
    Next("Int32", 2);
    Next("UInt16", 4);
    Next("Int16", 4);
    Next("Byte", 8);
    Next("SByte", 8);
    Next("Double", 1);
    Next("Single", 2);
#>
    }
}
<#+
void Seed(string T)
{
#>

        /// <summary>
        /// Create a pseudo-random number generator initialized with provided values.
        /// </summary>
        public RandomNumbers(params <#= T #>[] seed)
            : this(MakeBytes(seed))
        {
        }
<#+
}

void Next(string T, int m)
{
#>

        /// <summary>
        /// Get the next value in the pseudo-random sequence as a <see cref="<#= T #>"/>.
        /// </summary>
        public <#= T #> Next<#= T #>()
        {
            return (<#= T #>)Mix();
        }

        /// <summary>
        /// Fill a provided array of <see cref="UInt64"/> values with the next values in the pseudo-random sequence.
        /// </summary>
        public void GetNext(<#= T #>[] array)
        {
            GetNext(array, 0, array.Length);
        }

        /// <summary>
        /// Fill a provided array of <see cref="UInt64"/> values with the next values in the pseudo-random sequence.
        /// </summary>
        public void GetNext(<#= T #>[] array, int offset, int count)
        {
            if (array == null) 
                throw new ArgumentNullException(nameof(array));

            if (offset < 0 || offset >= array.Length) 
                throw new ArgumentOutOfRangeException(nameof(offset));

            if (count < 1 || count > array.Length - offset) 
                throw new ArgumentOutOfRangeException(nameof(count));

<#+
    string FP = T;

    if (T == "Single" || T == "Double")
    {
        FP = T == "Single" ? "UInt32" : "UInt64";
    }
#>
            while (count >= <#= m #>)
            {
                Mix();
<#+
    for (int i = m - 1; i >= 0; i--)
    {
        FixFP(T, FP, i);
#>
                array[offset++] = sample.<#= T #>_<#= i #>;
<#+
    }
#>
                count -= <#= m #>;
            }
<#+
    if (m == 2)
    {
#>

            if (count == 0)
                return;

            Mix();
            <#+ FixFP(T, FP, 1); #> 
            array[offset++] = sample.<#= T #>_1;
<#+
    }
    else if (m > 2)
    {
#>

            if (count == 0)
                return;

            Mix();

            switch (count)
            {
<#+
        for (int i = m - 1; i > 1; i--)
        {
#>
                case <#= i #>: array[offset++] = sample.<#= T #>_<#= i #>; goto case <#= i - 1 #>;
<#+
        }
#>
                case 1: array[offset++] = sample.<#= T #>_1; break;
            }
<#+
    }   // end if (m > 1)
#>
        }
<#+
}

void FixFP(string T, string FP, int i)
{
    if (T == "Double")
    {
#>
                sample.UInt64_0 = (sample.UInt64_0 & 0x000FFFFFFFFFFFFF) | 0x3FF0000000000000;
                sample.Double_0 -= 1d;
<#+        
    }
    else if (T == "Single")
    {
#>
                sample.UInt32_<#= i #> = (sample.UInt32_<#= i #> & 0x007FFFFF) | 0x3F800000;
                sample.Single_<#= i #> -= 1f;
<#+        
    }
}
#>