
/*
MixingFunctionsTests.cs

Copyright © 2016 Pluto Scarab Software. Most Rights Reserved.
Author: Bret Mulvey

This work is licensed under the Creative Commons Attribution-ShareAlike 4.0 International License. 
To view a copy of this license, visit http://creativecommons.org/licenses/by-sa/4.0/.

THIS IS AN AUTO-GENERATED SOURCE FILE. DO NOT EDIT THIS FILE DIRECTLY.
INSTEAD, EDIT THE .tt FILE WITH THE SAME NAME AND RE-RUN THE TEXT TEMPLATING
FILE GENERATOR. IF YOU SAVE THE FILE IN VISUAL STUDIO IT WILL DO THIS FOR YOU.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Foundations.Functions;

namespace Foundations.RandomNumbers
{
    /// <summary>
    /// 
    /// </summary>
	[TestClass]
	public class MixingFunctionsTests
    {
		[TestMethod]
		public void ByteTest()
		{
			var generator = new Generator();

			for (int t = 0; t < 100; t++)
			{
				var fn = MixingFunctions.CreateByteMixer(generator);
				var used = new HashSet<Byte>();

				for (int i = 0; i < 256; i++)
				{
					used.Add(fn((Byte)i));
				}

				Assert.AreEqual(256, used.Count);
			}
		}

		[TestMethod]
		public void SByteTest()
		{
			var generator = new Generator();

			for (int t = 0; t < 100; t++)
			{
				var fn = MixingFunctions.CreateSByteMixer(generator);
				var used = new HashSet<SByte>();

				for (int i = 0; i < 256; i++)
				{
					used.Add(fn((SByte)i));
				}

				Assert.AreEqual(256, used.Count);
			}
		}

		[TestMethod]
		public void CharTest()
		{
			var generator = new Generator();

			for (int t = 0; t < 100; t++)
			{
				var fn = MixingFunctions.CreateCharMixer(generator);
				var used = new HashSet<Char>();

				for (int i = 0; i < 256; i++)
				{
					used.Add(fn((Char)i));
				}

				Assert.AreEqual(256, used.Count);
			}
		}

		[TestMethod]
		public void UInt16Test()
		{
			var generator = new Generator();

			for (int t = 0; t < 100; t++)
			{
				var fn = MixingFunctions.CreateUInt16Mixer(generator);
				var used = new HashSet<UInt16>();

				for (int i = 0; i < 256; i++)
				{
					used.Add(fn((UInt16)i));
				}

				Assert.AreEqual(256, used.Count);
			}
		}

		[TestMethod]
		public void Int16Test()
		{
			var generator = new Generator();

			for (int t = 0; t < 100; t++)
			{
				var fn = MixingFunctions.CreateInt16Mixer(generator);
				var used = new HashSet<Int16>();

				for (int i = 0; i < 256; i++)
				{
					used.Add(fn((Int16)i));
				}

				Assert.AreEqual(256, used.Count);
			}
		}

		[TestMethod]
		public void UInt32Test()
		{
			var generator = new Generator();

			for (int t = 0; t < 100; t++)
			{
				var fn = MixingFunctions.CreateUInt32Mixer(generator);
				var used = new HashSet<UInt32>();

				for (int i = 0; i < 256; i++)
				{
					used.Add(fn((UInt32)i));
				}

				Assert.AreEqual(256, used.Count);
			}
		}

		[TestMethod]
		public void Int32Test()
		{
			var generator = new Generator();

			for (int t = 0; t < 100; t++)
			{
				var fn = MixingFunctions.CreateInt32Mixer(generator);
				var used = new HashSet<Int32>();

				for (int i = 0; i < 256; i++)
				{
					used.Add(fn((Int32)i));
				}

				Assert.AreEqual(256, used.Count);
			}
		}

		[TestMethod]
		public void UInt64Test()
		{
			var generator = new Generator();

			for (int t = 0; t < 100; t++)
			{
				var fn = MixingFunctions.CreateUInt64Mixer(generator);
				var used = new HashSet<UInt64>();

				for (int i = 0; i < 256; i++)
				{
					used.Add(fn((UInt64)i));
				}

				Assert.AreEqual(256, used.Count);
			}
		}

		[TestMethod]
		public void Int64Test()
		{
			var generator = new Generator();

			for (int t = 0; t < 100; t++)
			{
				var fn = MixingFunctions.CreateInt64Mixer(generator);
				var used = new HashSet<Int64>();

				for (int i = 0; i < 256; i++)
				{
					used.Add(fn((Int64)i));
				}

				Assert.AreEqual(256, used.Count);
			}
		}


    }
}
