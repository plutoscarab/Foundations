<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>

/*
Generator.cs

<#@ include file="../../License.txt" #>
*/

using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Foundations.RandomNumbers;

namespace Foundations.UnitTests.RandomNumbers
{
    [TestClass]
    public sealed class GeneratorTests
    {
<#
Type("Byte");
Type("SByte");
Type("UInt16");
Type("Int16");
Type("UInt32");
Type("Int32");
Type("UInt64");
Type("Int64");
Type("Single");
Type("Double");
Type("Decimal");
#>

        [TestMethod]
        [ExpectedException(typeof(System.Reflection.TargetInvocationException))]
        public void CreateStateUnsupportedArray()
        {
            var method = typeof(Generator).GetMethod("CreateState", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static, null, new[] { typeof(IRandomSource), typeof(byte[]), typeof(Array) }, null);
            var source = new SHA256RandomSource();
            var seed = new byte[] { 1, 2, 3 };
            Array state = new string[99];
            method.Invoke(null, new object[] { source, seed, state });
        }
    }
}
<#+
void Type(string T)
{
#>
        [TestMethod]
        public void Individual<#= T #>Values()
        {
            var random = new Generator(Generator.DefaultSourceFactory(), "Individual<#= T #>Values".ToCharArray());
            var data = new <#= T #>[99];

            for (int i = 0; i < data.Length; i++)
                data[i] = random.<#= T #>();

            LooksRandom(data);
        }
<#+
    if (T[0] == 'I' || T == "SByte")
    {
#>

        [TestMethod]
        public void IndividualNonNegative<#= T #>Values()
        {
            var random = new Generator();

            for (int i = 0; i < 1000; i++)
            {
                var value = random.<#= T #>NonNegative();
                Assert.IsTrue(value >= 0);
            }
        }

        [TestMethod]
        public void FillNonNegative<#= T #>()
        {
            var random = new Generator();
            var data = new <#= T #>[10000];
            random.FillNonNegative(data);

            for (int i = 0; i < data.Length; i++)
            {
                Assert.IsTrue(data[i] >= 0);
            }
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentNullException))]
        public void FillNullNonNegative<#= T #>()
        {
            var random = new Generator();
            random.FillNonNegative((<#= T #>[])null);
        }
<#+
    }
#>

        [TestMethod]
        public void Individual<#= T #>ValuesUpToRange()
        {
            var random = new Generator();
            var data = new <#= T #>[99];
            var hash = new HashSet<<#= T #>>();

            for (int i = 0; i < 10000; i++)
            {
                var x = random.<#= T #>(50);
                Assert.IsTrue(x >= 0);
                Assert.IsTrue(x < 50);
                hash.Add(x);
                if (hash.Count == 50) break;
            }

            Assert.AreEqual(50, hash.Count);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentOutOfRangeException))]
        public void Individual<#= T #>InvalidRange()
        {
            var random = new Generator();
            random.<#= T #>(0);
        }

        [TestMethod]
        public void Individual<#= T #>ValuesInRange()
        {
            var random = new Generator();
            var data = new <#= T #>[99];
            var hash = new HashSet<<#= T #>>();

            for (int i = 0; i < 10000; i++)
            {
                var x = random.<#= T #>(25, 50);
                Assert.IsTrue(x >= 25);
                Assert.IsTrue(x < 75);
                hash.Add(x);
                if (hash.Count == 50) break;
            }

            Assert.AreEqual(50, hash.Count);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentOutOfRangeException))]
        public void Individual<#= T #>ValuesInRangeTooLow()
        {
            var random = new Generator();
            random.<#= T #>(25, 0);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentOutOfRangeException))]
        public void Individual<#= T #>ValuesInRangeTooHigh()
        {
            var random = new Generator();
            random.<#= T #>(3 * (<#= T #>.MaxValue / 4), <#= T #>.MaxValue / 2);
        }

        [TestMethod]
        public void Random<#= T #>Arrays()
        {
            var random = new Generator("Random<#= T #>s".ToCharArray());

            for (int i = 0; i < 8; i++)
            {
                var data = new <#= T #>[99 + i];
                random.Fill(data);
                LooksRandom(data);
            }
        }

        [TestMethod]
        public void Random<#= T #>ArrayWithRange()
        {
            var random = new Generator();
            var data = new <#= T #>[10000];
            random.Fill(50, data);

            for (int i = 0; i < data.Length; i++)
            {
                Assert.IsTrue(data[i] >= 0);
                Assert.IsTrue(data[i] < 50);
            }
        }

        [TestMethod]
        public void Random<#= T #>ArrayWithMinAndRange()
        {
            var random = new Generator();
            var data = new <#= T #>[10000];
            random.Fill(25, 50, data);

            for (int i = 0; i < data.Length; i++)
            {
                Assert.IsTrue(data[i] >= 25);
                Assert.IsTrue(data[i] < 75);
            }
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentOutOfRangeException))]
        public void Random<#= T #>ArrayWithLowRange()
        {
            var random = new Generator();
            var data = new <#= T #>[10000];
            random.Fill(0, data);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentOutOfRangeException))]
        public void Random<#= T #>ArrayWithHighRange()
        {
            var random = new Generator();
            var data = new <#= T #>[10000];
            random.Fill(3 * (<#= T #>.MaxValue / 4), <#= T #>.MaxValue / 2, data);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentNullException))]
        public void RandomNull<#= T #>ArrayWithRange()
        {
            var random = new Generator();
            random.Fill(50, (<#= T #>[])null);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentNullException))]
        public void RandomNull<#= T #>ArrayWithMinAndRange()
        {
            var random = new Generator();
            random.Fill(0, 50, (<#= T #>[])null);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentNullException))]
        public void RandomNull<#= T #>SubArrayWithRange()
        {
            var random = new Generator();
            random.Fill(0, 50, (<#= T #>[])null, 0, 100);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentOutOfRangeException))]
        public void Random<#= T #>SubArrayWithLowOffset()
        {
            var random = new Generator("Random<#= T #>ArrayWithRange".ToCharArray());
            var data = new <#= T #>[99];
            random.Fill(0, 50, data, -1, 100);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentOutOfRangeException))]
        public void Random<#= T #>SubArrayWithHighOffset()
        {
            var random = new Generator("Random<#= T #>ArrayWithRange".ToCharArray());
            var data = new <#= T #>[99];
            random.Fill(0, 50, data, 99, 100);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentOutOfRangeException))]
        public void Random<#= T #>SubArrayWithLowCount()
        {
            var random = new Generator("Random<#= T #>ArrayWithRange".ToCharArray());
            var data = new <#= T #>[99];
            random.Fill(0, 50, data, 0, -1);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentOutOfRangeException))]
        public void Random<#= T #>SubArrayWithHighCount()
        {
            var random = new Generator("Random<#= T #>ArrayWithRange".ToCharArray());
            var data = new <#= T #>[99];
            random.Fill(0, 50, data, 0, 100);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentNullException))]
        public void Null<#= T #>Array()
        {
            var random = new Generator("Random<#= T #>s".ToCharArray());
            <#= T #>[] data = null;
            random.Fill(data);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentNullException))]
        public void Null<#= T #>ArrayWithOffsetCount()
        {
            var random = new Generator("Random<#= T #>s".ToCharArray());
            <#= T #>[] data = null;
            random.Fill(data, 0, 99);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentOutOfRangeException))]
        public void Low<#= T #>ArrayOffset()
        {
            var random = new Generator("Random<#= T #>s".ToCharArray());
            var data = new <#= T #>[99];
            random.Fill(data, -1, data.Length);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentOutOfRangeException))]
        public void High<#= T #>ArrayOffset()
        {
            var random = new Generator("Random<#= T #>s".ToCharArray());
            var data = new <#= T #>[99];
            random.Fill(data, data.Length, 0);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentOutOfRangeException))]
        public void Low<#= T #>ArrayCount()
        {
            var random = new Generator("Random<#= T #>s".ToCharArray());
            var data = new <#= T #>[99];
            random.Fill(data, 0, -1);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentOutOfRangeException))]
        public void High<#= T #>ArrayCount()
        {
            var random = new Generator("Random<#= T #>s".ToCharArray());
            var data = new <#= T #>[99];
            random.Fill(data, 0, data.Length + 1);
        }

        [TestMethod]
        public void Create<#= T #>State()
        {
            var method = typeof(Generator).GetMethod("CreateState", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static, null, new[] { typeof(IRandomSource), typeof(byte[]), typeof(<#= T #>[]) }, null);
            var source = new SHA256RandomSource();
            var seed = new byte[] { 1, 2, 3 };
            var state = new <#= T #>[99];
            method.Invoke(null, new object[] { source, seed, state });
            LooksRandom(state);
        }

        [TestMethod]
        public void Create<#= T #>StateWeaklyTyped()
        {
            var method = typeof(Generator).GetMethod("CreateState", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static, null, new[] { typeof(IRandomSource), typeof(byte[]), typeof(Array) }, null);
            var source = new SHA256RandomSource();
            var seed = new byte[] { 1, 2, 3 };
            Array state = new <#= T #>[99];
            method.Invoke(null, new object[] { source, seed, state });
            LooksRandom(state as <#= T #>[]);
        }

        [TestMethod]
        [ExpectedException(typeof(System.Reflection.TargetInvocationException))]
        public void Create<#= T #>StateNullSource()
        {
            var method = typeof(Generator).GetMethod("CreateState", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static, null, new[] { typeof(IRandomSource), typeof(byte[]), typeof(<#= T #>[]) }, null);
            IRandomSource source = null;
            var seed = new byte[] { 1, 2, 3 };
            var state = new <#= T #>[99];
            method.Invoke(null, new object[] { source, seed, state });
        }

        [TestMethod]
        [ExpectedException(typeof(System.Reflection.TargetInvocationException))]
        public void Create<#= T #>StateNullSeed()
        {
            var method = typeof(Generator).GetMethod("CreateState", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static, null, new[] { typeof(IRandomSource), typeof(byte[]), typeof(<#= T #>[]) }, null);
            var source = new SHA256RandomSource();
            byte[] seed = null;
            var state = new <#= T #>[99];
            method.Invoke(null, new object[] { source, seed, state });
        }

        [TestMethod]
        [ExpectedException(typeof(System.Reflection.TargetInvocationException))]
        public void Create<#= T #>StateNullState()
        {
            var method = typeof(Generator).GetMethod("CreateState", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static, null, new[] { typeof(IRandomSource), typeof(byte[]), typeof(<#= T #>[]) }, null);
            var source = new SHA256RandomSource();
            byte[] seed = new byte[] { 1, 2, 3 };
            <#= T #>[] state = null;
            method.Invoke(null, new object[] { source, seed, state });
        }

<#+ if (T != "Decimal") { #>
        [TestMethod]
        public void SeedWith<#= T #>s()
        {
            var random = new Generator("SeedWith<#= T #>s".ToCharArray());
            var data = new <#= T #>[99];
            random.Fill(data);
            random = new Generator(data);
            random.Fill(data);
            LooksRandom(data);
        }

        [TestMethod]
        public void SeedWith<#= T #>sAndSource()
        {
            var random = new Generator("SeedWith<#= T #>s".ToCharArray());
            var data = new <#= T #>[99];
            random.Fill(data);
            var source = Generator.DefaultSourceFactory();
            random = new Generator(source, data);
            random.Fill(data);
            LooksRandom(data);
        }

<#+ } #>
        [TestMethod]
        public void Random<#= T #>SeededWithNull()
        {
            var source = new XorShiftRandomSource();
            var random = new Generator(source, (byte[])null);
            var data = new <#= T #>[99];
            random.Fill(data);
            LooksRandom(data);
        }

        [TestMethod]
        public void Random<#= T #>FromEntropy()
        {
            var random = new Generator();
            var data = new <#= T #>[99];
            random.Fill(data);
            LooksRandom(data);
        }

        [TestMethod]
        public void Random<#= T #>FromEntropyAndSource()
        {
            var source = Generator.DefaultSourceFactory();
            var random = new Generator(source);
            var data = new <#= T #>[99];
            random.Fill(data);
            LooksRandom(data);
        }

        private void LooksRandom(<#= T #>[] array)
        {
<#+ if (T == "Single" || T == "Double" || T == "Decimal") { #>
            var minValue = 0.0;
            var maxValue = 1.0;
<#+ } else { #>
            var minValue = (double)<#= T #>.MinValue;
            var maxValue = (double)<#= T #>.MaxValue;
<#+ } #>
            var range = (maxValue - minValue) / 8;
            var min = array.Min(t => (double)t);
            Assert.IsTrue(min < minValue + range);
            var max = array.Max(t => (double)t);
            Assert.IsTrue(max > maxValue - range);
            var avg = array.Average(t => (double)t);
            var mid = (minValue + maxValue) / 2.0;
            Assert.IsTrue(avg > mid - range);
            Assert.IsTrue(avg < mid + range);
        }

<#+
}
#>